% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\else\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig. }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{0}


\title{LimaDetector CPP Tango device Documentation}
\date{Jan 09, 2018}
\release{1.8.1}
\author{langlois noureddine}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


This is the C++ \textbf{LimaDetector} Tango device server developped at SOLEIL.

{\hspace*{\fill}\scalebox{0.600000}{\includegraphics{{Soleil_Lima_Device}.png}}}

This device server provides several Tango classes:
\begin{itemize}
\item {} 
\textbf{LimaDetector} : Generic class for the standard camera control

\item {} 
\textbf{CameraType} : A camera specific class for the camera configuration (see the list below)

\item {} 
Optionnal classes:

\end{itemize}
\begin{itemize}
\item {} 
\textbf{RoiCounters} : Allows to set Rois and get some statistic for each roi (sum, average, std ...)

\item {} 
\textbf{Layout} : Allows to modify the original image (flip, rotation, additions ...)

\item {} 
\textbf{FlatField} : Allows to modify the original image by substracting a flatfield image

\item {} 
\textbf{BackgroundSubstraction} : Allows to modify the original image by substracting a background image

\end{itemize}


\bigskip\hrule{}\bigskip



\chapter{LimaDetector class}
\label{LimaDetector/limadetector:limadetector-class}\label{LimaDetector/limadetector:c-tango-device-server}\label{LimaDetector/limadetector::doc}
\textbf{LimaDetector} is the generic class and it provides a unique interface to control any supported camera. One can find below the
properties, commands, and attributes.

To run a LimaDetector device you will need at least to configure the \textbf{DetectorType} property. This property is used by the LimaDetector device to communicate with the proper camera plugin. Please refer a specific camera (e.g Basler) device chapter for further information.


\section{Property}
\label{LimaDetector/limadetector:property}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textsf{\relax 
Property name
} & \textsf{\relax 
Mandatory
} & \textsf{\relax 
Default value
} & \textsf{\relax 
Description
}\\
\hline
AccThresholdCallbackModule
 & 
No
 & 
``''
 & 
Plugin file name which manages threshold, see acc\_saturated\_* attributes and the *AccSaturated* commands to activate and use  this feature
\\
\hline
BufferMaxMemory
 & 
No
 & 
70
 & 
The maximum among of memory in percent of the available RAM
that Lima is using to allocate frame buffer.
\\
\hline
ConfigurationFilePath
 & 
No
 & 
\textasciitilde{}/lima\_\textless{}serv-name\textgreater{}.cfg
 & 
The default configuration file path
\\
\hline
ConfigurationDefaultName
 & 
No
 & 
``default''
 & 
Your default configuration name
\\
\hline
IntrumentName
 & 
No
 & 
``''
 & 
The instrument name, e.g ESRF-ID02 (\textbf{*})
\\
\hline
DetectorType
 & 
Yes
 & 
N/A
 & 
The camera type: e.g. Maxipix
\\
\hline
MaxVideoFPS
 & 
No
 & 
30
 & 
Maximum value for frame-per-second
\\
\hline
NbProcessingThread
 & 
No
 & 
1
 & 
The max number of thread for processing.
Can be used to improve the performance
when more than 1 task (plugin device) is activated
\\
\hline
TangoEvent
 & 
No
 & 
False
 & 
Activate Tango Event for counters and new images
\\
\hline
UserDetectorName
 & 
No
 & 
``''
 & 
A user detector identifier, e.g frelon-saxs, (\textbf{*})
\\
\hline\end{tabulary}


(\textbf{*}) Properties only used to set meta-data in HDF5 saving format.


\section{Commands}
\label{LimaDetector/limadetector:commands}
\begin{tabular}{|p{0.237\linewidth}|p{0.237\linewidth}|p{0.237\linewidth}|p{0.237\linewidth}|}
\hline
\textsf{\relax 
\textbf{Command name}
} & \textsf{\relax 
\textbf{Arg. in}
} & \textsf{\relax 
\textbf{Arg. out}
} & \textsf{\relax 
\textbf{Description}
}\\
\hline
Init
 & 
DevVoid
 & 
DevVoid
 & 
Do not use
\\
\hline
State
 & 
DevVoid
 & 
DevLong
 & 
Return the device state
\\
\hline
Status
 & 
DevVoid
 & 
DevString
 & 
Return the device state as a string
\\
\hline
getAttrStringValueList
 & 
DevString:
Attribute name
 & 
DevVarStringArray:
String value list
 & 
Return the authorized string value list for a given attribute name
\\
\hline
prepareAcq
 & 
DevVoid
 & 
DevVoid
 & 
Prepare the camera for a new acquisition, has to be called each time a parameter is set.
\\
\hline
startAcq
 & 
DevVoid
 & 
DevVoid
 & 
Start the acquisition
\\
\hline
stopAcq
 & 
DevVoid
 & 
DevVoid
 & 
Stop the acquisition after current frame is acquired, and wait for all tasks to finish
\\
\hline
abortAcq
 & 
DevVoid
 & 
DevVoid
 & 
Abort the acquisition, the current frame is lost
\\
\hline
setImageHeader
 & 
DevVarStringArray:
Array of string header
 & 
DevVoid
 & \begin{description}
\item[{Set the image header:}] \leavevmode\begin{itemize}
\item {} 
{[}0{]}=''ImageId0 delimiter imageHeader0,

\item {} 
{[}1{]} = ImageId1 delimiter  imageHeader1..

\end{itemize}

\end{description}
\\
\hline
resetCommonHeader
 & 
DevVoid
 & 
DevVoid
 & 
Reset the common header
\\
\hline
resetFrameHeaders
 & 
DevVoid
 & 
DevVoid
 & 
Reset the frame headers
\\
\hline
getImage
 & 
DevLong: Image number(0-N)
 & 
DevVarCharArray: Image data
 & 
Return the image data in raw format (char array)
\\
\hline
getBaseImage
 & 
DevLong: Image number(0-N)
 & 
DevVarCharArray: Image data
 & 
Return the base image data in raw format (char array). Base image is the raw image before processing
\\
\hline
readImage
 & 
DevLong: Image number(0-N)
 & 
DevEncoded: Encoded image
 & 
Return the image in encoded format of type ``\textbf{DATA\_ARRAY}'' (see {\hyperref[LimaDetector/limadetector:data\string-array\string-encoded]{\crossref{\DUrole{std,std-ref}{DevEncoded DATA\_ARRAY}}}})
\\
\hline
readImageSeq
 & 
DevLongArray: Image number(0-N) list
 & 
DevEncoded: Encoded image(S)
 & 
Return a stack of images in encoded format of type ``\textbf{DATA\_ARRAY}'' (see {\hyperref[LimaDetector/limadetector:data\string-array\string-encoded]{\crossref{\DUrole{std,std-ref}{DevEncoded DATA\_ARRAY}}}})
\\
\hline
writeImage
 & 
DevLong: Image number(0-N)
 & 
DevVoid
 & 
Save manually an image
\\
\hline
readAccSaturatedImageCounter
 & 
DevLong: Image number
 & 
DevVarUShortArray: Image counter
 & 
The image counter
\\
\hline
readAccSaturatedSumCounter
 & 
DevLong: from image id
 & 
DevVarLongArray: result
 & 
number of result for each images,sum counter of raw image \#0 of image \#0,sum counter of raw image \#1
of image \#0,...
\\
\hline
setAccSaturatedMask
 & 
DevString
 & 
DevVoid
 & 
Full path of mask file, use empty string (``'') to unset the mask
\\
\hline
closeShutterManual
 & 
DevVoid
 & 
DevVoid
 & 
Only if the camera has this capability
\\
\hline
openShutterManual
 & 
DevVoid
 & 
DevVoid
 & 
Only if the camera has this capability
\\
\hline
reset
 & 
DevVoid
 & 
DevVoid
 & 
Reset the camera to factory setting
\\
\hline
getPluginDeviceNameFromType
 & 
DevString
 & 
DevString
 & 
Return the device name corresponding to the passed plugin named (.e.g FlatField)
\\
\hline
configStore
 & 
DevVarStringArray:config name,module1,
module2, ... , modulen
 & 
DevVoid
 & 
Store (im memory) a current config with name and for the listed modules (e.g. \textbf{Acquisition},
\textbf{Image}, \textbf{RoiCounters}, \textbf{Saving} ...).
See the \emph{config\_available\_name} and \emph{config\_available\_module} attributes for full list.
\\
\hline
configApply
 & 
DevString: config name
 & 
DevVoid
 & 
Apply the named config
\\
\hline
configPop
 & 
DevVoid
 & 
DevVoid
 & 
Pop the named config from the list
\\
\hline
configDelete
 & 
DevVoid
 & 
DevVoid
 & 
Delete the named config
\\
\hline
configFileSave
 & 
DevVoid
 & 
DevVoid
 & 
Save all the config into file (see properties for config file name)
\\
\hline
configFileLoad
 & 
DevVoid
 & 
DevVoid
 & 
Load the configs from file
\\
\hline\end{tabular}



\section{Attributes}
\label{LimaDetector/limadetector:attributes}
You will here a long list of attributes, this reflects the richness of the LIMA library. We organized them in
modules which correspond to specific functions. A function module is identified by an attribute name prefix (excepted for informationnal attributes),
for instance the \textbf{Acquisition} module attributes  are always named \textbf{acq\_\textless{}attr-name\textgreater{}}. The available modules are :
\begin{itemize}
\item {} 
General Information

\item {} 
Status  (prefix \emph{last\_} and \emph{ready\_})

\item {} 
Acquisition (prefix \emph{acq\_} for most of them sorry)

\item {} 
Accumulation (prefix \emph{acc\_})

\item {} 
Saving  (prefix \emph{saving\_})

\item {} 
Image (prefix \emph{image\_})

\item {} 
Shutter (prefix \emph{shutter\_})

\item {} 
Debug   (prefix \emph{debug\_})

\item {} 
Video   (prefix \emph{video\_})

\item {} 
Shared Memory (prefix \emph{shared\_memory\_})

\item {} 
Configuration (prefix \emph{config\_})

\item {} 
Buffer (prefix \emph{buffer\_})

\item {} 
Plugin (prefix \emph{plugin\_})

\end{itemize}

Many attributes are of type DevString and they have a fixed list of possible values. you can get the list by calling the special command
\textbf{getAttrStringValueList}. Because a camera cannot support some attribute values , the command getAttrStringValueList will give you the
the value list for the camera. For instance the attribute \emph{video\_mode} supports up to 14 different video formats, but a camera can only supports
few of them.

\begin{longtable}{|p{0.237\linewidth}|p{0.237\linewidth}|p{0.237\linewidth}|p{0.237\linewidth}|}
\hline
\textsf{\relax 
Attribute name
} & \textsf{\relax 
RW
} & \textsf{\relax 
Type
} & \textsf{\relax 
Description
}\\
\hline\endfirsthead

\multicolumn{4}{c}%
{{\tablecontinued{\tablename\ \thetable{} -- continued from previous page}}} \\
\hline
\textsf{\relax 
Attribute name
} & \textsf{\relax 
RW
} & \textsf{\relax 
Type
} & \textsf{\relax 
Description
}\\
\hline\endhead

\hline \multicolumn{4}{|r|}{{\tablecontinued{Continued on next page}}} \\ \hline
\endfoot

\endlastfoot



 & 

 & 
\textbf{GENERAL INFORMATION}
 & 

\\
\hline
lima\_type
 & 
ro
 & 
DevString
 & 
LImA camera type:
Maxipix,Pilatus,Frelon,Pco, Basler ...
\\
\hline
camera\_type
 & 
ro
 & 
DevString
 & 
Like lima\_type but in upper-case  !!
\\
\hline
camera\_pixelsize
 & 
ro
 & 
DevDouble{[}x,y{]}
 & 
The camera pixel size in x and y dimension
\\
\hline
camera\_model
 & 
ro
 & 
DevString
 & 
Camera model return by the detector layer:.e.g. 5x1- TPX1
\\
\hline

 & 

 & 

 & 

\\
\hline

 & 

 & 
\textbf{STATUS}
 & 

\\
\hline
last\_base\_image\_ready
 & 
ro
 & 
DevLong
 & 
The last base (before treatment) ready
\\
\hline
last\_image\_ready
 & 
ro
 & 
DevLong
 & 
The last acquired image number, ready for reading
\\
\hline
last\_image\_saved
 & 
ro
 & 
DevLong
 & 
The last saved image number
\\
\hline
last\_image\_acquired
 & 
ro
 & 
DevLong
 & 
The last acquired image number
\\
\hline
last\_counter\_ready
 & 
ro
 & 
DevLong
 & 
Tell which image counter is last ready
\\
\hline
ready\_for\_next\_image
 & 
ro
 & 
DevBoolean
 & 
True after a camera readout, otherwise false. Can be
used for fast synchronisation with trigger mode (internal
or external).
\\
\hline
ready\_for\_next\_acq
 & 
ro
 & 
DevBoolean
 & 
True after end of acquisition, otherwise false.
\\
\hline
user\_detector\_name
 & 
rw
 & 
DevString
 & 
User detector name
\\
\hline
instrument\_name
 & 
rw
 & 
DevString
 & 
Intrument/beamline name
\\
\hline

 & 

 & 

 & 

\\
\hline

 & 

 & 
\textbf{ACQUISITION}
 & 

\\
\hline
acq\_status
 & 
ro
 & 
DevString
 & 
Acquisition status: Ready, Running, Fault or Configuration
\\
\hline
acq\_status\_fault\_error
 & 
ro
 & 
DevString
 & 
In case of Fault state, return the error message
\\
\hline
acq\_mode
 & 
rw
 & 
DevString
 & \begin{description}
\item[{Acquisition mode:}] \leavevmode\begin{itemize}
\item {} 
\textbf{Single}, default mode one frame per image

\item {} 
\textbf{Concatenation}, frames are concatenated in image

\item {} 
\textbf{Accumulation}, powerful mode to avoid saturation
of the pixel, the exposure is shared
by multiple frames, see acc\_ attributes for more

\end{itemize}

\end{description}
\\
\hline
acq\_nb\_frames
 & 
rw
 & 
DevLong
 & 
Number of frames to be acquired, Default is 1 frame
\\
\hline
acq\_trigger\_mode
 & 
rw
 & 
DevString
 & \begin{description}
\item[{Trigger mode:}] \leavevmode\begin{itemize}
\item {} 
\textbf{Internal\_trigger}, the software trigger,
start the acquisition immediately after an acqStart() call,
all the acq\_nb\_frames are acquired in an sequence.

\item {} 
\textbf{External\_trigger}, wait for an external trigger signal
to start the an acquisition for the acq\_nb\_frames number
of frames.

\item {} 
\textbf{External\_trigger\_multi}, as the previous mode except
that each frames need a new trigger input
(e.g. for 4 frames 4 pulses are waiting for)

\item {} 
\textbf{Internal\_trigger\_multi}, as for internal\_trigger except
that for each frame the startAcq() has to called once.

\item {} 
\textbf{External\_gate}, wait for a gate signal for each frame,
the gate period is the exposure time.

\item {} 
\textbf{External\_start\_stop}

\end{itemize}

\end{description}
\\
\hline
latency\_time
 & 
rw
 & 
DevDouble
 & 
Latency time in second between two frame acquisitions,
can not be zero, the minimum time corresponds to the
readout time of the detector.
\\
\hline
valid\_ranges
 & 
ro
 & 
DevDouble{[}4{]}
 & 
min exposure, max exposure, min latency, max latency
\\
\hline
concat\_nb\_frames
 & 
rw
 & 
DevLong
 & 
The nb of frames to concatenate in one image
\\
\hline
acq\_expo\_time
 & 
rw
 & 
DevDouble
 & 
The exposure time of the image, Default is 1 second
\\
\hline

 & 

 & 

 & 

\\
\hline

 & 

 & 
\textbf{ACCUMULATION}
 & 

\\
\hline
acc\_expotime
 & 
ro
 & 
DevDouble
 & 
The effective accumulation total exposure time.
\\
\hline
acc\_nb\_frames
 & 
ro
 & 
DevLong
 & 
The calculated accumulation number of frames per image.
\\
\hline
acc\_max\_expotime
 & 
rw
 & 
DevDouble
 & 
The maximum exposure time per frame for accumulation
\\
\hline
acc\_time\_mode
 & 
rw
 & 
DevString
 & \begin{description}
\item[{Accumulation time mode:}] \leavevmode\begin{itemize}
\item {} 
\textbf{Live},acq\_expo\_time = acc\_live\_time

\item {} 
\textbf{Real},acq\_expo\_time = acc\_dead\_time + acc\_live\_time

\end{itemize}

\end{description}
\\
\hline
acc\_dead\_time
 & 
ro
 & 
DevDouble
 & 
Total accumulation dead time
\\
\hline
acc\_live\_time
 & 
ro
 & 
DevDouble
 & 
Total accumulation live time which corresponds to the
detector total counting time.
\\
\hline
acc\_offset\_before
 & 
rw
 & 
DevLong
 & 
Set a offset value to be added to each pixel value
\\
\hline
acc\_saturated\_active
 & 
rw
 & 
DevBoolean
 & 
To activate the saturation counters (i.e. readAccSaturated commands)
\\
\hline
acc\_saturated\_cblevel
 & 
rw
 & 
DevLong
 & 
Set at which level of total saturated pixels the callback plugin (if set with the AccThresholdCallbackModule property) will be called
\\
\hline
acc\_saturated\_threshold
 & 
rw
 & 
DevLong
 & 
The threshold for counting saturated pixels
\\
\hline
acc\_threshold\_before
 & 
rw
 & 
DevLong
 & 
Set a threshold value to be substract to each pixel value
\\
\hline

 & 

 & 

 & 

\\
\hline

 & 

 & 
\textbf{SAVING}
 & 

\\
\hline
saving\_mode
 & 
rw
 & 
DevString
 & \begin{description}
\item[{Saving mode:}] \leavevmode\begin{itemize}
\item {} 
\textbf{Manual}, no automatic saving, a command will
be implemented in a next release to be able to
save an acquired image.

\item {} 
\textbf{Auto\_Frame}, Frames are automatically saved
according the saving parameters (see below).

\item {} 
\textbf{Auto\_header}, Frames are only saved when the
setImageHeader() is called in order to set
header information with image data.

\end{itemize}

\end{description}
\\
\hline
saving\_directory
 & 
rw
 & 
DevString
 & 
The directory where to save the image files
\\
\hline
saving\_prefix
 & 
rw
 & 
DevString
 & 
The image file prefix
\\
\hline
saving\_suffix
 & 
rw
 & 
DevString
 & 
The image file suffix
\\
\hline
saving\_next\_number
 & 
rw
 & 
DevLong
 & 
The image next number
The full image file name is:
/saving\_directory/saving\_prefix+sprintf(``\%04d'',saving\_next\_number)+saving\_suffix
\\
\hline
saving\_format
 & 
rw
 & 
DevString
 & \begin{description}
\item[{The data format for saving:}] \leavevmode\begin{itemize}
\item {} 
\textbf{Raw}, save in binary format

\item {} 
\textbf{Edf}, save in ESRF Data Format

\item {} 
\textbf{edfgz} (or edf.gz), EDF with gz compression

\item {} 
\textbf{Tiff}, The famous TIFF format

\item {} 
\textbf{Cbf}, save in CBF format (a compressed format
for crystallography)

\end{itemize}

\end{description}
\\
\hline
saving\_overwrite\_policy
 & 
rw
 & 
DevString
 & \begin{description}
\item[{In case of existing files an overwite policy is mandatory:}] \leavevmode\begin{itemize}
\item {} 
\textbf{Abort}, if the file exists the saving is aborted

\item {} 
\textbf{Overwrite}, if the file exists it is overwritten

\item {} 
\textbf{Append}, if the file exists the image is append
to the file

\end{itemize}

\end{description}
\\
\hline
saving\_frame\_per\_file
 & 
rw
 & 
DevLong
 & 
Number of frames saved in each file
\\
\hline
saving\_common\_header
 & 
rw
 & 
DevString{[}{]}
 & 
Common header with multiple entries
\\
\hline
saving\_header\_delimiter
 & 
rw
 & 
DevString{[}{]}
 & 
The header delimiters, {[}0{]} = key header delimiter, {[}1{]} =
entry header delimiter, {[}2{]} = image number header
delimiter. Default : {[}0{]} = ``='', {[}1{]} = ``n'', {[}2{]} = '';''
\\
\hline
saving\_max\_writing\_task
 & 
rw
 & 
DevShort
 & 
Set the max. tasks for saving file, default is 1
\\
\hline
saving\_statistics
 & 
ro
 & 
DevDouble{[}{]}
 & 
Return stats: saving speed, compression ratio,
compression speed and incoming speed (speed in byte/s)
\\
\hline
saving\_statistics\_history
 & 
rw
 & 
DevLong
 & 
Set size of history for stats calculation, default is 16 frames
\\
\hline

 & 

 & 

 & 

\\
\hline

 & 

 & 
\textbf{IMAGE}
 & 

\\
\hline
image\_type
 & 
ro
 & 
DevString
 & \begin{description}
\item[{Return the current image data type, bit per pixel signed or unsigned:}] \leavevmode\begin{itemize}
\item {} 
Bpp8, Bpp8S, Bpp10, Bpp10S, Bpp12, Bpp12S, Bpp14,

\item {} 
Bpp14S, Bpp16, Bpp16S, Bpp32, Bpp32S , Bpp32F.

\end{itemize}

\end{description}
\\
\hline
image\_width
 & 
ro
 & 
DevLong
 & 
Width size of the detector in pixel
\\
\hline
image\_height
 & 
ro
 & 
DevLong
 & 
Height size of the detector in pixel
\\
\hline
image\_sizes
 & 
ro
 & 
DevULong{[}4{]}
 & 
Signed(0-unsigned,1-signed), depth(nb bytes), width and height
\\
\hline
image\_roi
 & 
rw
 & 
DevLong{[}4{]}
 & 
Region Of Interest on image, {[}0{]} = Begin X, {[}1{]} = End X,
{[}2{]} Begin Y, {[}3{]} = End Y, default ROI is {[}0,0,0,0{]} (no ROI)
\\
\hline
image\_bin
 & 
rw
 & 
DevLong{[}2{]}
 & 
Binning on image, {[}0{]} = Binning factor on X, {[}1{]} =
Binning factor on Y. Default binning is 1 x 1
\\
\hline
image\_flip
 & 
rw
 & 
DevBoolean{[}2{]}
 & 
Flip on the image, {[}0{]} = flip over X axis, {[}1{]} flip over Y
axis. Default flip is False x False
\\
\hline
image\_rotation
 & 
rw
 & 
DevString
 & 
Rotate the image: ``0'', ``90'', ``180'' or ``270''
\\
\hline

 & 

 & 

 & 

\\
\hline

 & 

 & 
\textbf{SHUTTER}
 & 

\\
\hline
shutter\_mode
 & 
rw
 & 
DevString
 & \begin{description}
\item[{Synchronization for shutter,  modes are available:}] \leavevmode\begin{itemize}
\item {} 
\textbf{Manual}

\item {} 
\textbf{Auto\_frame}, the output signal is activated for each individual frame of a sequence

\item {} 
\textbf{Auto\_sequence}, the output signal is activated
during the whole sequence

\end{itemize}

\end{description}
\\
\hline
shutter\_open\_time
 & 
rw
 & 
DevDouble
 & 
Delay (sec.) between the output shutter trigger and the
beginning of the acquisition, if not null the shutter signal
is set on before the acquisition is started.
\\
\hline
shutter\_close\_time
 & 
rw
 & 
DevDouble
 & 
Delay (sec.) between the shutter trigger and the end of
the acquisition, if not null the shutter signal is set on
before the end of the acquisition.
\\
\hline
shutter\_manual\_state
 & 
rw
 & 
DevString
 & 
To open/close manually the shutter (if Manual mode is supported, see shutter\_mode)
\\
\hline

 & 

 & 

 & 

\\
\hline

 & 

 & 
\textbf{DEBUG}
 & 

\\
\hline
debug\_module\_possible
 & 
ro
 & 
DevString{[}{]}
 & 
Return the list of possible debug modules
\\
\hline
debug\_modules
 & 
rw
 & 
DevString{[}{]}
 & \begin{description}
\item[{Set the debug module level of LImA:}] \leavevmode\begin{itemize}
\item {} 
``None''

\item {} 
``Common''

\item {} 
``Hardware''

\item {} 
``HardwareSerial''

\item {} 
``Control''

\item {} 
``Espia''

\item {} 
``EspiaSerial''

\item {} 
``Focla''

\item {} 
``Camera''

\item {} 
``CameraCom''

\item {} 
``Test''

\item {} 
``Application''

\end{itemize}

\end{description}
\\
\hline
debug\_types\_possible
 & 
ro
 & 
DevString{[}{]}
 & 
Return the list of the possible debug types
\\
\hline
debug\_types
 & 
rw
 & 
DevString{[}{]}
 & \begin{description}
\item[{Set the debug type level of LImA:}] \leavevmode\begin{itemize}
\item {} 
``Fatal''

\item {} 
``Error''

\item {} 
``Warning''

\item {} 
``Trace''

\item {} 
``Funct''

\item {} 
``Param''

\item {} 
``Return''

\item {} 
``Always''

\end{itemize}

\end{description}
\\
\hline

 & 

 & 

 & 

\\
\hline

 & 

 & 
\textbf{VIDEO}
 & 

\\
\hline
video\_active
 & 
rw
 & 
DevBoolean
 & 
Start the video mode (or not)
\\
\hline
video\_live
 & 
rw
 & 
DevBoolean
 & 
Start the video streaming (or not)
\\
\hline
video\_exposure
 & 
rw
 & 
DevDouble
 & 
The video exposure time (can be different to the acq\_expo\_time)
\\
\hline
video\_gain
 & 
rw
 & 
DevDouble
 & 
The video gain (if supported by the hardware)
\\
\hline
video\_mode
 & 
rw
 & 
DevString
 & \begin{description}
\item[{The video mode is the video format supported by the camera, it can be:}] \leavevmode\begin{itemize}
\item {} 
Y8, grey image 8bits

\item {} 
Y16, grey image 16bits

\item {} 
Y32, grey image 32bits

\item {} 
RGB555, color image RGB 555 encoding

\item {} 
RGB564, color image RGB 555 encoding

\item {} 
RGB24,  color image RGB 24bits encoding

\item {} 
RGB32, color image RGB 32bits encoding

\item {} 
BGR24, color image BGR 24bits encoding

\item {} 
BGR32, color image BGR 32bits encoding

\item {} 
BAYER\_RG8, color image BAYER RG 8bits encoding

\item {} 
BAYER\_RG16, color image BAYER RG 16bits encoding

\item {} 
I420, color image I420 (or YUV420) planar encoding

\item {} 
YUV411, color image YUV411 planar encoding

\item {} 
YUV422PACKED, color image YUV422 planar encoding packed

\item {} 
YUV422, color image YUV422 planar encoding

\item {} 
YUV444, color image YUV444 planar encoding

\end{itemize}

\end{description}

Depending of your camera, the supported formats can be retrieve
using the command \textbf{getAttrStringValueList}
\\
\hline
video\_roi
 & 
rw
 & 
DevLong{[}4{]}
 & 
A ROI on the video image (independent of the image\_roi attribute)
\\
\hline
video\_bin
 & 
rw
 & 
DevULong{[}2{]}
 & 
A Binning on the video image (independt of the image\_bin attribute)
\\
\hline
video\_last\_image
 & 
rw
 & 
DevEncoded
 & 
The last video image, in DevEncoded ``\textbf{VIDEO\_IMAGE}'' format, and using
the video\_mode set, see the DevEncoded definition {\hyperref[LimaDetector/limadetector:video\string-image\string-encoded]{\crossref{\DUrole{std,std-ref}{DevEncoded VIDEO\_IMAGE}}}}
\\
\hline
video\_source
 & 
rw
 & 
DevString
 & 
The source for video image, BASE\_IMAGE (raw image) or LAST\_IMAGE (after soft operation)
Only valid with monochrome or scientific cameras
\\
\hline
video\_last\_image\_counter
 & 
rw
 & 
DevLong64
 & 
The image counter
\\
\hline

 & 

 & 

 & 

\\
\hline

 & 

 & 
\textbf{SHARED MEMORY}
 & 

\\
\hline
shared\_memory\_names
 & 
rw
 & 
DevString{[}2{]}
 & 
Firstname and surname of the SPS typed shared memory (default is LimaCCDs,\textless{}camera\_type\textgreater{})
\\
\hline
shared\_memory\_active
 & 
rw
 &  & 
Activate or not the shared memory. The shared memory is for image display
\\
\hline

 & 

 & 

 & 

\\
\hline

 & 

 & 
\textbf{CONFIG}
 & 

\\
\hline
config\_available\_module
 & 
ro
 & 
DevString{[}{]}
 & 
List of possible config modules,
\\
\hline
config\_available\_name
 & 
ro
 & 
DevString{[}{]}
 & 
List of existing config names
\\
\hline

 & 

 & 
\textbf{BUFFER}
 & 

\\
\hline
buffer\_max\_memory
 & 
rw
 & 
DevShort
 & 
The maximum among of memory in percent of the available RAM
that Lima is using to allocate frame buffer.
\\
\hline

 & 

 & 
\textbf{PLUGIN}
 & 

\\
\hline
plugin\_type\_list
 & 
ro
 & 
DevString{[}{]}
 & 
List of the available plugin type, to get one device name
use instead the \textbf{getPluginDeviceNameFromType} command
\\
\hline
plugin\_list
 & 
ro
 & 
DevString{[}{]}
 & 
List of the available plugin as couple of type, device name
\\
\hline\end{longtable}



\subsection{DevEncoded DATA\_ARRAY}
\label{LimaDetector/limadetector:devencoded-data-array}\label{LimaDetector/limadetector:data-array-encoded}
The DATA\_ARRAY DevEncoded has been invented for special Tango client like SPEC. It is used by the \textbf{readImage} command.
It can only embed raw data (no video data). The supported image format can be retrieve with the \textbf{image\_type} attribute (Bpp8,Bpp8S, ..., Bpp16,..)
This encoded format is very generic and it supports many different type of data from scalar to image stack (see DataArrayCategory enumerate C-type).
The readImage command only supports  \emph{Image} data array category.

The DATA\_ARRAY format is composed of a fixed header followed by the raw data. The header is a C-like structure,
with \textbf{little-endian} byte order and no alignment:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} The DATA\PYGZus{}ARRAY definition}
\PYG{n}{struct} \PYG{p}{\PYGZob{}}
    \PYG{n}{unsigned} \PYG{n+nb}{int}       \PYG{n}{magic}\PYG{o}{=} \PYG{l+m+mh}{0x44544159}\PYG{p}{;} \PYG{o}{/}\PYG{o}{/} \PYG{n}{magic} \PYG{n}{key}
    \PYG{n}{unsigned} \PYG{n}{short}     \PYG{n}{version}\PYG{p}{;}           \PYG{o}{/}\PYG{o}{/} \PYG{n}{version}\PYG{p}{,} \PYG{n}{only} \PYG{l+m+mi}{1} \PYG{n}{supported}
    \PYG{n}{unsigned}  \PYG{n}{short}    \PYG{n}{header\PYGZus{}size}\PYG{p}{;}       \PYG{o}{/}\PYG{o}{/} \PYG{n}{size} \PYG{n}{of} \PYG{n}{the} \PYG{n}{header}
    \PYG{n}{DataArrayCategory}  \PYG{n}{category}\PYG{p}{;}          \PYG{o}{/}\PYG{o}{/} \PYG{n}{data} \PYG{n}{array} \PYG{n}{category}\PYG{p}{,} \PYG{n}{see} \PYG{n}{DataArrayCategory} \PYG{n+nb}{enumerate}
    \PYG{n}{DataArrayType}      \PYG{n}{data\PYGZus{}type}\PYG{p}{;}         \PYG{o}{/}\PYG{o}{/} \PYG{n}{data} \PYG{n+nb}{type}\PYG{p}{,} \PYG{n}{see} \PYG{n}{DataArrayType} \PYG{n+nb}{enumerate}
    \PYG{n}{unsigned} \PYG{n}{short}     \PYG{n}{endianness}\PYG{p}{;}        \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{0}\PYG{o}{\PYGZhy{}}\PYG{n}{little}\PYG{o}{\PYGZhy{}}\PYG{n}{endian}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{big}\PYG{o}{\PYGZhy{}}\PYG{n}{endian}
    \PYG{n}{unsigned} \PYG{n}{short}     \PYG{n}{nb\PYGZus{}dim}\PYG{p}{;}            \PYG{o}{/}\PYG{o}{/} \PYG{n}{number} \PYG{n}{of} \PYG{n}{dimension} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{to} \PYG{l+m+mi}{7} \PYG{n+nb}{max}\PYG{p}{)}\PYG{n}{e}\PYG{o}{.}\PYG{n}{g} \PYG{l+m+mi}{2} \PYG{k}{for} \PYG{n}{image}
    \PYG{n}{unsigned} \PYG{n}{short}     \PYG{n}{dim}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{;}            \PYG{o}{/}\PYG{o}{/} \PYG{n}{size} \PYG{k}{for} \PYG{n}{each} \PYG{n}{dimension}\PYG{p}{,} \PYG{n}{e}\PYG{o}{.}\PYG{n}{g} \PYG{p}{[}\PYG{n}{width}\PYG{p}{,}\PYG{n}{height}\PYG{p}{]}
    \PYG{n}{unsigned} \PYG{n+nb}{int}       \PYG{n}{dim\PYGZus{}step}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{;}       \PYG{o}{/}\PYG{o}{/} \PYG{n}{step} \PYG{n}{size} \PYG{o+ow}{in} \PYG{n}{pixel} \PYG{k}{for} \PYG{n}{each} \PYG{n}{dimension}\PYG{p}{,} \PYG{n}{e}\PYG{o}{.}\PYG{n}{g} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{height}\PYG{p}{]}
\PYG{p}{\PYGZcb{}} \PYG{n}{DATA\PYGZus{}ARRAY\PYGZus{}STRUCT}\PYG{p}{;}

\PYG{n}{enum} \PYG{n}{DataArrayCategory} \PYG{p}{\PYGZob{}}
    \PYG{n}{ScalarStack} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{Spectrum}\PYG{p}{;}
    \PYG{n}{Image}\PYG{p}{;}
    \PYG{n}{SpectrumStack}\PYG{p}{;}
    \PYG{n}{ImageStack}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{n}{enum} \PYG{n}{DataArrayType}\PYG{p}{\PYGZob{}}
    \PYG{n}{DARRAY\PYGZus{}UINT8} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{DARRAY\PYGZus{}UINT16}\PYG{p}{;}
    \PYG{n}{DARRAY\PYGZus{}UINT32}\PYG{p}{;}
    \PYG{n}{DARRAY\PYGZus{}UINT64}\PYG{p}{;}
    \PYG{n}{DARRAY\PYGZus{}INT8}\PYG{p}{;}
    \PYG{n}{DARRAY\PYGZus{}INT16}\PYG{p}{;}
    \PYG{n}{DARRAY\PYGZus{}INT32}\PYG{p}{;}
    \PYG{n}{DARRAY\PYGZus{}INT64}\PYG{p}{;}
    \PYG{n}{DARRAY\PYGZus{}FLOAT32}\PYG{p}{;}
    \PYG{n}{DARRAY\PYGZus{}FLOAT64}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}


\subsection{DevEncoded VIDEO\_IMAGE}
\label{LimaDetector/limadetector:video-image-encoded}\label{LimaDetector/limadetector:devencoded-video-image}
The VIDEO\_IMAGE DevEncoded has been implemented for the \textbf{video\_last\_image} attribute to return the last image. It can
embed any of the supported video format depending of the \textbf{video\_mode} attribute value.

The VIDEO\_IMAGE format is composed of a fixed header followed by the  data. The header is a C-like structure,
with  \textbf{big-endian} byte order  and no alignment:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{struct} \PYG{p}{\PYGZob{}}
    \PYG{n}{unsigned} \PYG{n+nb}{int}     \PYG{n}{magic\PYGZus{}number} \PYG{o}{=} \PYG{l+m+mh}{0x5644454f}\PYG{p}{;}
    \PYG{n}{unsigned} \PYG{n}{short}   \PYG{n}{version}\PYG{p}{;}        \PYG{o}{/}\PYG{o}{/} \PYG{n}{only} \PYG{n}{version} \PYG{l+m+mi}{1} \PYG{o+ow}{is} \PYG{n}{supported}
    \PYG{n}{unsigned} \PYG{n}{short}   \PYG{n}{image\PYGZus{}mode}\PYG{p}{;}     \PYG{o}{/}\PYG{o}{/} \PYG{n}{Y8}\PYG{p}{,}\PYG{n}{Y16}\PYG{p}{,}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
    \PYG{n}{long}     \PYG{n}{long}    \PYG{n}{frame\PYGZus{}number}\PYG{p}{;}   \PYG{o}{/}\PYG{o}{/} \PYG{n}{the} \PYG{n}{frame} \PYG{n}{number} \PYG{p}{(}\PYG{n}{counter}\PYG{p}{)}
    \PYG{n+nb}{int}              \PYG{n}{width}\PYG{p}{;}          \PYG{o}{/}\PYG{o}{/} \PYG{n}{the} \PYG{n}{frame} \PYG{n}{width} \PYG{o+ow}{in} \PYG{n}{pixel} \PYG{p}{(}\PYG{n}{horizontal} \PYG{n}{size}\PYG{p}{)}
    \PYG{n+nb}{int}              \PYG{n}{height}          \PYG{o}{/}\PYG{o}{/} \PYG{n}{the} \PYG{n}{frame} \PYG{n}{height} \PYG{o+ow}{in} \PYG{n}{pixel} \PYG{p}{(}\PYG{n}{vertical} \PYG{n}{size}\PYG{p}{)}
    \PYG{n}{unsigned} \PYG{n}{short}   \PYG{n}{endianness}\PYG{p}{;}     \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{0}\PYG{o}{\PYGZhy{}}\PYG{n}{little}\PYG{o}{\PYGZhy{}}\PYG{n}{endian}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{big}\PYG{o}{\PYGZhy{}}\PYG{n}{endian}
    \PYG{n}{unsigned} \PYG{n}{short}   \PYG{n}{header\PYGZus{}size}\PYG{p}{;}    \PYG{o}{/}\PYG{o}{/} \PYG{n}{this} \PYG{n}{header} \PYG{n}{size} \PYG{o+ow}{in} \PYG{n}{byte}
    \PYG{n}{unsigned} \PYG{n}{short}   \PYG{n}{padding}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}     \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{4} \PYG{n+nb}{bytes} \PYG{n}{of} \PYG{n}{padding} \PYG{p}{(}\PYG{k}{for} \PYG{n}{alignment}\PYG{p}{)}
\PYG{p}{\PYGZcb{}} \PYG{n}{VIDEO\PYGZus{}IMAGE\PYGZus{}STRUCT}\PYG{p}{;}
\end{Verbatim}


\subsubsection{Camera devices}
\label{LimaDetector/limadetector:camera-devices}
Each camera has a configuration device with its own property/attribute/command lists.
The camera configuration device is supposed to give you access to the ``private'' parameters
of the detector that LIMA does not need but you may want to set. For instance some detectors
provides a temperature control with set-points and/or start/stop commands for a auxillary cooling
system.

For more details about the camera device interface, please have a look on the following sections:


\subsubsection{Plugin devices: software operation and extra interfaces}
\label{LimaDetector/limadetector:plugin-devices-software-operation-and-extra-interfaces}
User-defined software plugins can be used to execute arbitrary image-based operations. An entry point in the control layer completely exports the ProcessLib functionality, allowing an external code to be called on every frame. The software operation can be implemented in C++ or Python.

The software operations on image are embedded into individual Tango devices and are available in the \textbf{plugins/} directory. They are automatically exported
by the LimaCCDs server.
\begin{description}
\item[{The software operations are of two types, \emph{Sink} or \emph{Link} :}] \leavevmode\begin{itemize}
\item {} 
\textbf{Link} operation is supposed to modify the frame data, so it gets the frame data as input parameter and it will return a ``corrected'' image (e.g. Mask/Flatfield/BackgroundSubstraction).

\item {} 
\textbf{Sink} operation  is taken the frame data as input parameter to apply some software operation in order to return new data like statistics, peak positions, alarm on saturation ... etc.

\end{itemize}

\end{description}

In addition to sink/link plugin device, a plugin can just be implemented to provide/export a subset of the Lima interface or a legacy interface for some specific client applications (e.g SPEC, LimaTacoCCD plugin).

Today there are about  8 standard plugin devices:
\begin{itemize}
\item {} 
BackgroundSubstraction : link operation, to correct the frames with a background image (substraction)

\item {} 
FlatField:               link operation to correct the frames with a flatfield image (divide + option normalisation)

\item {} 
Mask:                    link operation to mask pixels. Very useful if some pixel are not working properly and if you want to set then to a fix value or to zero.

\item {} 
PeakFinder:              thanks to Teresa Numez from DESY, a sink operation which can detect diffraction peaks.

\item {} 
Roi2Spectrum:            sink operation to apply ROI spectrum on the frames. You can define more than one spectra with ROI coordinates and by specifying in which direction you need to bin the values, vertical or horizontal.

\item {} 
RoiCounter:              sink operation to get calculating statistics on image regions.

\item {} 
LimaTacoCCD: extra interface for TACO clients, it only provides commands (TACO does not have attribute !), it is still used at ESRF for SPEC.

\item {} 
LiveViewer:  extra interface  to provide a live view of the last acquired image, can be used from atkpanel.

\end{itemize}

If you need to implement your own plugin device we can provide you some example codes, use the mailing-list \href{mailto:lima@esrf.fr}{lima@esrf.fr} to get help.


\chapter{Andor Tango device}
\label{AndorCCD/andorccd::doc}\label{AndorCCD/andorccd:andor-tango-device}
This is the reference documentation of the Andor Tango device.

you can also find some useful information about prerequisite/installation/configuration/compilation in the \DUrole{xref,std,std-ref}{Andor camera plugin} section.


\section{Properties}
\label{AndorCCD/andorccd:properties}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textsf{\relax 
Property name
} & \textsf{\relax 
Mandatory
} & \textsf{\relax 
Default value
} & \textsf{\relax 
Description
}\\
\hline
adc\_speed
 & 
No
 & 
max.
 & 
The adc/Horiz. speed pair
\\
\hline
baseline\_clamp
 & 
No
 & 
Off
 & 
Clamping for baseline threshold, ON or OFF
\\
\hline
camera\_number
 & 
No
 & 
N/A
 & 
The camera number,  default is  0
\\
\hline
cooler
 & 
No
 & 
Off
 & 
Start/stop the cooling system of the camera mode
\\
\hline
config\_path
 & 
No
 & 
N/A
 & 
The configuration path, for linux default is /usr/local/etc/andor
\\
\hline
fast\_ext\_trigger
 & 
No
 & 
Off
 & 
Fast external trigger mode, see Andor documentation for usage
\\
\hline
fan\_mode
 & 
No
 & 
N/A
 & 
FAN mode, FAN\_ON\_FULL/FAN\_ON\_LOW/FAN\_OFF
\\
\hline
high\_capacity
 & 
No
 & 
High\_capacity
 & 
Camera can run in two modes, HIGH\_CAPACITY or HIGH\_SENSITIVITY
\\
\hline
p\_gain
 & 
No
 & 
max.
 & 
The preamplifier gain {[}X1-Xn{]} (see detector spec.)
\\
\hline
shutter\_level
 & 
No
 & 
High
 & 
The shutter output level mode
\\
\hline
temperature\_sp
 & 
No
 & 
N/A
 & 
The temperature setpoint in Celsius
\\
\hline
vs\_speed
 & 
No
 & 
fasten
 & 
The vertical shift speed (see detector spec.)
\\
\hline\end{tabulary}



\section{Attributes}
\label{AndorCCD/andorccd:attributes}
\begin{tabular}{|p{0.237\linewidth}|p{0.237\linewidth}|p{0.237\linewidth}|p{0.237\linewidth}|}
\hline
\textsf{\relax 
Attribute name
} & \textsf{\relax 
RW
} & \textsf{\relax 
Type
} & \textsf{\relax 
Description
}\\
\hline
adc\_speed
 & 
rw
 & 
DevString
 & 
The  ADC and Horizontal shift speed, in ADCchannel/Freq.Mhz, check
the documentatio for more help \textbf{(*)}
\\
\hline
baseline\_clamp
 & 
rw
 & 
DevString
 & \begin{description}
\item[{The baseline clamping for threshold: \textbf{(**)}}] \leavevmode\begin{itemize}
\item {} 
\textbf{ON}

\item {} 
\textbf{OFF}

\end{itemize}

\end{description}
\\
\hline
cooler
 & 
rw
 & 
DevString
 & \begin{description}
\item[{Start/stop the cooling system of the camera mode:}] \leavevmode\begin{itemize}
\item {} 
\textbf{ON}, the cooler is started

\item {} 
\textbf{OFF}, the cooler is stopped

\end{itemize}

\end{description}
\\
\hline
cooling\_status
 & 
ro
 & 
DevString
 & 
The status of the cooling system, tell if the setpoint
temperature is reached
\\
\hline
fan\_mode
 & 
rw
 & 
DevString
 & \begin{description}
\item[{The FAN mode for extra-cooling: \textbf{(**)}}] \leavevmode\begin{itemize}
\item {} 
\textbf{FAN\_OFF}

\item {} 
\textbf{FAN\_ON\_FULL}

\item {} 
\textbf{FAN\_ON\_LOW}

\end{itemize}

\end{description}
\\
\hline
fast\_ext\_trigger
 & 
rw
 & 
DevString
 & \begin{description}
\item[{Fast external trigger mode, see Andor documentation for usage Mode are:}] \leavevmode\begin{itemize}
\item {} 
\textbf{ON}, fast mode, the camera will not wait until the a keep clean cycle has been completed before accepting the next
trigger

\item {} 
\textbf{OFF}, slow mode

\end{itemize}

\end{description}
\\
\hline
high\_capacity
 & 
rw
 & 
DevString
 & \begin{description}
\item[{Off/On the High Capacity mode: \textbf{(**)}}] \leavevmode\begin{itemize}
\item {} 
\textbf{HIGH\_CAPACITY}

\item {} 
\textbf{HIGH\_SENSITIVITY}

\end{itemize}

\end{description}
\\
\hline
p\_gain
 & 
rw
 & 
DevString
 & 
The preamplifier gain from X1 to Xn (see detector spec.) \textbf{(*)}
\\
\hline
shutter\_level
 & 
rw
 & 
DevString
 & \begin{description}
\item[{The shutter output level mode:}] \leavevmode\begin{itemize}
\item {} 
\textbf{LOW''}, output TTL low signal to open shutter

\item {} 
\textbf{HIGH}, output TTL high signal to open shutter

\end{itemize}

\end{description}
\\
\hline
temperature
 & 
ro
 & 
DevShort
 & 
The current sensor temperature in Celsius
\\
\hline
temperature\_sp
 & 
rw
 & 
DevShort
 & 
The temperature setpoint in Celsius
\\
\hline
timing
 & 
ro
 & 
Spectrum
 & 
The exposure and latency times
\\
\hline
vs\_speed
 & 
rw
 & 
DevString
 & 
The vertical shift speed, in us/pixel \textbf{(*)}
\\
\hline\end{tabular}


\textbf{(*)} Use the command getAttrStringValueList to get the list of the supported value for these attributes.

\textbf{(**)} These attributes can not be supported by some camera models and the return value will be set to  \textbf{UNSUPPORTED}.


\section{Commands}
\label{AndorCCD/andorccd:commands}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textsf{\relax 
Command name
} & \textsf{\relax 
Arg. in
} & \textsf{\relax 
Arg. out
} & \textsf{\relax 
Description
}\\
\hline
Init
 & 
DevVoid
 & 
DevVoid
 & 
Do not use
\\
\hline
State
 & 
DevVoid
 & 
DevLong
 & 
Return the device state
\\
\hline
Status
 & 
DevVoid
 & 
DevString
 & 
Return the device state as a string
\\
\hline
getAttrStringValueList
 & 
DevString:
Attribute name
 & 
DevVarStringArray:
String value list
 & 
Return the authorized string value list for
a given attribute name
\\
\hline\end{tabulary}



\chapter{Aviex Tango device}
\label{AviexCCD/aviexccd:aviex-tango-device}\label{AviexCCD/aviexccd::doc}
This is the reference documentation of the Aviex Tango device.

you can also find some useful information about prerequisite/installation/configuration/compilation in the \DUrole{xref,std,std-ref}{Aviex camera plugin} section.


\section{Properties}
\label{AviexCCD/aviexccd:properties}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textsf{\relax 
Property name
} & \textsf{\relax 
Mandatory
} & \textsf{\relax 
Default value
} & \textsf{\relax 
Description
}\\
\hline
adc\_speed
 & 
No
 & 
max.
 & 
The adc/Horiz. speed pair
\\
\hline
baseline\_clamp
 & 
No
 & 
Off
 & 
Clamping for baseline threshold, ON or OFF
\\
\hline
camera\_number
 & 
No
 & 
N/A
 & 
The camera number,  default is  0
\\
\hline
cooler
 & 
No
 & 
Off
 & 
Start/stop the cooling system of the camera mode
\\
\hline
config\_path
 & 
No
 & 
N/A
 & 
The configuration path, for linux default is /usr/local/etc/andor
\\
\hline
fast\_ext\_trigger
 & 
No
 & 
Off
 & 
Fast external trigger mode, see Aviex documentation for usage
\\
\hline
fan\_mode
 & 
No
 & 
N/A
 & 
FAN mode, FAN\_ON\_FULL/FAN\_ON\_LOW/FAN\_OFF
\\
\hline
high\_capacity
 & 
No
 & 
High\_capacity
 & 
Camera can run in two modes, HIGH\_CAPACITY or HIGH\_SENSITIVITY
\\
\hline
p\_gain
 & 
No
 & 
max.
 & 
The preamplifier gain {[}X1-Xn{]} (see detector spec.)
\\
\hline
shutter\_level
 & 
No
 & 
High
 & 
The shutter output level mode
\\
\hline
temperature\_sp
 & 
No
 & 
N/A
 & 
The temperature setpoint in Celsius
\\
\hline
vs\_speed
 & 
No
 & 
fasten
 & 
The vertical shift speed (see detector spec.)
\\
\hline\end{tabulary}



\section{Attributes}
\label{AviexCCD/aviexccd:attributes}
\begin{tabular}{|p{0.237\linewidth}|p{0.237\linewidth}|p{0.237\linewidth}|p{0.237\linewidth}|}
\hline
\textsf{\relax 
Attribute name
} & \textsf{\relax 
RW
} & \textsf{\relax 
Type
} & \textsf{\relax 
Description
}\\
\hline
adc\_speed
 & 
rw
 & 
DevString
 & 
The  ADC and Horizontal shift speed, in ADCchannel/Freq.Mhz, check
the documentatio for more help \textbf{(*)}
\\
\hline
baseline\_clamp
 & 
rw
 & 
DevString
 & \begin{description}
\item[{The baseline clamping for threshold: \textbf{(**)}}] \leavevmode\begin{itemize}
\item {} 
\textbf{ON}

\item {} 
\textbf{OFF}

\end{itemize}

\end{description}
\\
\hline
cooler
 & 
rw
 & 
DevString
 & \begin{description}
\item[{Start/stop the cooling system of the camera mode:}] \leavevmode\begin{itemize}
\item {} 
\textbf{ON}, the cooler is started

\item {} 
\textbf{OFF}, the cooler is stopped

\end{itemize}

\end{description}
\\
\hline
cooling\_status
 & 
ro
 & 
DevString
 & 
The status of the cooling system, tell if the setpoint
temperature is reached
\\
\hline
fan\_mode
 & 
rw
 & 
DevString
 & \begin{description}
\item[{The FAN mode for extra-cooling: \textbf{(**)}}] \leavevmode\begin{itemize}
\item {} 
\textbf{FAN\_OFF}

\item {} 
\textbf{FAN\_ON\_FULL}

\item {} 
\textbf{FAN\_ON\_LOW}

\end{itemize}

\end{description}
\\
\hline
fast\_ext\_trigger
 & 
rw
 & 
DevString
 & \begin{description}
\item[{Fast external trigger mode, see Andor documentation for usage Mode are:}] \leavevmode\begin{itemize}
\item {} 
\textbf{ON}, fast mode, the camera will not wait until the a keep clean cycle has been completed before accepting the next
trigger

\item {} 
\textbf{OFF}, slow mode

\end{itemize}

\end{description}
\\
\hline
high\_capacity
 & 
rw
 & 
DevString
 & \begin{description}
\item[{Off/On the High Capacity mode: \textbf{(**)}}] \leavevmode\begin{itemize}
\item {} 
\textbf{HIGH\_CAPACITY}

\item {} 
\textbf{HIGH\_SENSITIVITY}

\end{itemize}

\end{description}
\\
\hline
p\_gain
 & 
rw
 & 
DevString
 & 
The preamplifier gain from X1 to Xn (see detector spec.) \textbf{(*)}
\\
\hline
shutter\_level
 & 
rw
 & 
DevString
 & \begin{description}
\item[{The shutter output level mode:}] \leavevmode\begin{itemize}
\item {} 
\textbf{LOW''}, output TTL low signal to open shutter

\item {} 
\textbf{HIGH}, output TTL high signal to open shutter

\end{itemize}

\end{description}
\\
\hline
temperature
 & 
ro
 & 
DevShort
 & 
The current sensor temperature in Celsius
\\
\hline
temperature\_sp
 & 
rw
 & 
DevShort
 & 
The temperature setpoint in Celsius
\\
\hline
timing
 & 
ro
 & 
Spectrum
 & 
The exposure and latency times
\\
\hline
vs\_speed
 & 
rw
 & 
DevString
 & 
The vertical shift speed, in us/pixel \textbf{(*)}
\\
\hline\end{tabular}


\textbf{(*)} Use the command getAttrStringValueList to get the list of the supported value for these attributes.

\textbf{(**)} These attributes can not be supported by some camera models and the return value will be set to  \textbf{UNSUPPORTED}.


\section{Commands}
\label{AviexCCD/aviexccd:commands}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textsf{\relax 
Command name
} & \textsf{\relax 
Arg. in
} & \textsf{\relax 
Arg. out
} & \textsf{\relax 
Description
}\\
\hline
Init
 & 
DevVoid
 & 
DevVoid
 & 
Do not use
\\
\hline
State
 & 
DevVoid
 & 
DevLong
 & 
Return the device state
\\
\hline
Status
 & 
DevVoid
 & 
DevString
 & 
Return the device state as a string
\\
\hline
getAttrStringValueList
 & 
DevString:
Attribute name
 & 
DevVarStringArray:
String value list
 & 
Return the authorized string value list for
a given attribute name
\\
\hline\end{tabulary}



\chapter{Basler Tango C++ device}
\label{BaslerCCD/baslerccd:lima-tango-basler}\label{BaslerCCD/baslerccd:basler-tango-c-device}\label{BaslerCCD/baslerccd::doc}
This is the reference documentation of the Basler Tango C++ device.

you can also find some useful information about the camera models/prerequisite/installation/configuration/compilation in the \DUrole{xref,std,std-ref}{Basler camera plugin} section.


\section{Properties}
\label{BaslerCCD/baslerccd:properties}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textsf{\relax 
Property name
} & \textsf{\relax 
Mandatory
} & \textsf{\relax 
Default value
} & \textsf{\relax 
Description
}\\
\hline
camera\_id
 & 
No
 & 
uname://\emph{\textless{}server instance name\textgreater{}}
 & 
The camera ID (see details below)
\\
\hline
packet\_size
 & 
No
 & 
8000
 & 
the packet size
\\
\hline
inter\_packet\_delay
 & 
No
 & 
0
 & 
The inter packet delay
\\
\hline
frame\_transmission\_delay
 & 
No
 & 
0
 & 
The frame transmission delay
\\
\hline\end{tabulary}


\emph{camera\_id} property identifies the camera in the network. Several types of ID might be given:
\begin{itemize}
\item {} 
IP/hostname (examples: \titleref{ip://192.168.5.2}, \titleref{ip://white\_beam\_viewer1.esrf.fr})

\item {} 
Basler serial number (example: \titleref{sn://12345678})

\item {} 
Basler user name (example: \titleref{uname://white\_beam\_viewer1})

\end{itemize}

If no \emph{camera\_id} is given, it uses the server instance name as the camera user name (example, if your server is
called \titleref{LimaCCDs/white\_beam\_viewer1}, the default value for \emph{camera\_id} will be \titleref{uname://white\_beam\_viewer1}).

To maintain backward compatibility, the old \emph{cam\_ip\_address} is still supported but is considered deprecated
and might disappear in the future.

Both inter\_packet\_delay and frame\_tranmission\_delay properties can be used to tune the GiGE performance, for
more information on how to configure a GiGE Basler camera please refer to the Basler documentation.


\section{Attributes}
\label{BaslerCCD/baslerccd:attributes}
This camera device has not attribute.


\section{Commands}
\label{BaslerCCD/baslerccd:commands}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textsf{\relax 
Command name
} & \textsf{\relax 
Arg. in
} & \textsf{\relax 
Arg. out
} & \textsf{\relax 
Description
}\\
\hline
Init
 & 
DevVoid
 & 
DevVoid
 & 
Do not use
\\
\hline
State
 & 
DevVoid
 & 
DevLong
 & 
Return the device state
\\
\hline
Status
 & 
DevVoid
 & 
DevString
 & 
Return the device state as a string
\\
\hline
getAttrStringValueList
 & 
DevString:
Attribute name
 & 
DevVarStringArray:
String value list
 & 
Return the authorized string value list for
a given attribute name
\\
\hline\end{tabulary}



\chapter{Eiger Tango device}
\label{Eiger/eiger:eiger-tango-device}\label{Eiger/eiger::doc}
This is the reference documentation of the Dectris Eiger Tango device.

you can also find some useful information about the camera models/prerequisite/installation/configuration/compilation in the \DUrole{xref,std,std-ref}{Dectris Eiger camera plugin} section.


\section{Properties}
\label{Eiger/eiger:properties}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textsf{\relax 
Property name
} & \textsf{\relax 
Mandatory
} & \textsf{\relax 
Default value
} & \textsf{\relax 
Description
}\\
\hline
detector\_ip\_address
 & 
Yes
 & 
N/A
 & 
The ip address or the hostname of the detector computer interface
\\
\hline\end{tabulary}



\section{Attributes}
\label{Eiger/eiger:attributes}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textsf{\relax 
Attribute name
} & \textsf{\relax 
RW
} & \textsf{\relax 
Type
} & \textsf{\relax 
Description
}\\
\hline
auto\_summation
 & 
rw
 & 
DevString
 & 
If enable image depth is bpp32 and, if not image depth is bpp16 \textbf{(*)}
\\
\hline
countrate\_correction
 & 
rw
 & 
DevString
 & 
Enable or disable the countrate correction \textbf{(*)}
\\
\hline
efficency\_correction
 & 
rw
 & 
DevString
 & 
Enable the efficienty correction
\\
\hline
flatfield\_correction
 & 
rw
 & 
DevString
 & 
Enable or disable the internal (vs. lima) flatfield correction \textbf{(*)}
\\
\hline
humidity
 & 
ro
 & 
DevFloat
 & 
Return the humidity percentage
\\
\hline
pixel\_mask
 & 
rw
 & 
DevString
 & 
Enable or disable the pixel mask correction \textbf{(*)}
\\
\hline
photon\_energy
 & 
rw
 & 
DevFloat
 & 
The photon energy,it should be set to the incoming beam energy. Actually it?s an helper which set the threshold
\\
\hline
threshold\_energy
 & 
rw
 & 
DevFloat
 & 
The threshold energy, it will set the camera detection threshold. This should be set between 50 to 60 \% of the incoming beam energy.
\\
\hline
temperature
 & 
ro
 & 
DevFloat
 & 
The sensor temperature
\\
\hline
virtual\_pixel\_correction
 & 
rw
 & 
DevString
 & 
Enable or disable the virtual-pixel correction \textbf{(*)}
\\
\hline\end{tabulary}


\textbf{(*)} These attributes can take as value \textbf{ON} or \textbf{OFF}. Please refer to the Dectris documention for more information regarding
the online corrections.


\section{Commands}
\label{Eiger/eiger:commands}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textsf{\relax 
Command name
} & \textsf{\relax 
Arg. in
} & \textsf{\relax 
Arg. out
} & \textsf{\relax 
Description
}\\
\hline
deleteMemoryFiles
 & 
DevVoid
 & 
DevVoid
 & 
To remove the temporary mem. files
\\
\hline
Init
 & 
DevVoid
 & 
DevVoid
 & 
Do not use
\\
\hline
State
 & 
DevVoid
 & 
DevLong
 & 
Return the device state
\\
\hline
Status
 & 
DevVoid
 & 
DevString
 & 
Return the device state as a string
\\
\hline
getAttrStringValueList
 & 
DevString:
Attribute name
 & 
DevVarStringArray:
String value list
 & 
Return the authorized string value list for
a given attribute name
\\
\hline\end{tabulary}



\chapter{Hamamatsu Tango device}
\label{Hamamatsu/hamamatsu:hamamatsu-tango-device}\label{Hamamatsu/hamamatsu::doc}
This is the reference documentation of the Hamamatsu Tango device.

you can also find some useful information about the camera models/prerequisite/installation/configuration/compilation in the \DUrole{xref,std,std-ref}{Dectris Eiger camera plugin} section.


\section{Properties}
\label{Hamamatsu/hamamatsu:properties}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textsf{\relax 
Property name
} & \textsf{\relax 
Mandatory
} & \textsf{\relax 
Default value
} & \textsf{\relax 
Description
}\\
\hline
detector\_ip\_address
 & 
Yes
 & 
N/A
 & 
The ip address or the hostname of the detector computer interface
\\
\hline\end{tabulary}



\section{Attributes}
\label{Hamamatsu/hamamatsu:attributes}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textsf{\relax 
Attribute name
} & \textsf{\relax 
RW
} & \textsf{\relax 
Type
} & \textsf{\relax 
Description
}\\
\hline
auto\_summation
 & 
rw
 & 
DevString
 & 
If enable image depth is bpp32 and, if not image depth is bpp16 \textbf{(*)}
\\
\hline
countrate\_correction
 & 
rw
 & 
DevString
 & 
Enable or disable the countrate correction \textbf{(*)}
\\
\hline
efficency\_correction
 & 
rw
 & 
DevString
 & 
Enable the efficienty correction
\\
\hline
flatfield\_correction
 & 
rw
 & 
DevString
 & 
Enable or disable the internal (vs. lima) flatfield correction \textbf{(*)}
\\
\hline
humidity
 & 
ro
 & 
DevFloat
 & 
Return the humidity percentage
\\
\hline
pixel\_mask
 & 
rw
 & 
DevString
 & 
Enable or disable the pixel mask correction \textbf{(*)}
\\
\hline
photon\_energy
 & 
rw
 & 
DevFloat
 & 
The photon energy,it should be set to the incoming beam energy. Actually it?s an helper which set the threshold
\\
\hline
threshold\_energy
 & 
rw
 & 
DevFloat
 & 
The threshold energy, it will set the camera detection threshold. This should be set between 50 to 60 \% of the incoming beam energy.
\\
\hline
temperature
 & 
ro
 & 
DevFloat
 & 
The sensor temperature
\\
\hline
virtual\_pixel\_correction
 & 
rw
 & 
DevString
 & 
Enable or disable the virtual-pixel correction \textbf{(*)}
\\
\hline\end{tabulary}


\textbf{(*)} These attributes can take as value \textbf{ON} or \textbf{OFF}. Please refer to the Dectris documention for more information regarding
the online corrections.


\section{Commands}
\label{Hamamatsu/hamamatsu:commands}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textsf{\relax 
Command name
} & \textsf{\relax 
Arg. in
} & \textsf{\relax 
Arg. out
} & \textsf{\relax 
Description
}\\
\hline
deleteMemoryFiles
 & 
DevVoid
 & 
DevVoid
 & 
To remove the temporary mem. files
\\
\hline
Init
 & 
DevVoid
 & 
DevVoid
 & 
Do not use
\\
\hline
State
 & 
DevVoid
 & 
DevLong
 & 
Return the device state
\\
\hline
Status
 & 
DevVoid
 & 
DevString
 & 
Return the device state as a string
\\
\hline
getAttrStringValueList
 & 
DevString:
Attribute name
 & 
DevVarStringArray:
String value list
 & 
Return the authorized string value list for
a given attribute name
\\
\hline\end{tabulary}



\chapter{PCO Tango device}
\label{Pco/pco::doc}\label{Pco/pco:pco-tango-device}
This is the reference documentation of the PCO Tango device.

You can also find some useful information about the camera models/prerequisite/installation/configuration/compilation in the \DUrole{xref,std,std-ref}{PCO camera plugin} section.


\section{Properties}
\label{Pco/pco:properties}
\begin{tabular}{|p{0.237\linewidth}|p{0.237\linewidth}|p{0.237\linewidth}|p{0.237\linewidth}|}
\hline
\textsf{\relax 
Property name
} & \textsf{\relax 
Mandatory
} & \textsf{\relax 
Default value
} & \textsf{\relax 
Description
}\\
\hline
debug\_control
 & 
No
 & 
0
 & 
Enable/Disble the debug (0/1)
\\
\hline
debug\_module
 & 
No
 & 
0
 & \begin{description}
\item[{To set the debug module list (in hex format 0x....)}] \leavevmode\begin{itemize}
\item {} 
None           = 0x001

\item {} 
Common         = 0x002

\item {} 
Hardware       = 0x004

\item {} 
HardwareSerial = 0x008

\item {} 
Control        = 0x010

\item {} 
Espia          = 0x020

\item {} 
EspiaSerial    = 0x040

\item {} 
Focla          = 0x080

\item {} 
Camera         = 0x100

\item {} 
CameraCom      = 0x200

\item {} 
Test           = 0x400

\item {} 
Application    = 0x800

\end{itemize}

\end{description}
\\
\hline
debug\_format
 & 
No
 & 
0
 & \begin{description}
\item[{To set the debug format (in hex format 0x....)}] \leavevmode\begin{itemize}
\item {} 
DateTime = 0x001

\item {} 
Thread   = 0x002

\item {} 
Module   = 0x004

\item {} 
Obj      = 0x008

\item {} 
Funct    = 0x010

\item {} 
FileLine = 0x020

\item {} 
Type     = 0x040

\item {} 
Indent   = 0x080

\item {} 
Color    = 0x100

\end{itemize}

\end{description}
\\
\hline
debug\_type
 & 
No
 & 
0
 & \begin{description}
\item[{To set the debug type (in hex format 0x....)}] \leavevmode\begin{itemize}
\item {} 
Fatal   = 0x001

\item {} 
Error   = 0x002

\item {} 
Warning = 0x004

\item {} 
Trace   = 0x008

\item {} 
Funct   = 0x010

\item {} 
Param   = 0x020

\item {} 
Return  = 0x040

\item {} 
Always  = 0x080

\end{itemize}

\end{description}
\\
\hline
params
 & 
No
 & 
empty
 & \begin{description}
\item[{List of parameters/options (one per line)}] \leavevmode\begin{itemize}
\item {} 
sn = \textless{}camera serial number\textgreater{}
(
if it is 0 or doesn't exist, the first camera found will be opened
if the serial number is not found, OpenCam will fail
)

\item {} 
trigSingleMulti = 1
(
enable TriggerSingleMulti as TriggerMulti for compability
with SPEC START
)

\item {} 
xMinSize = 1
(
enable correction for the X minimum size for the CLHS firmware bug
)

\item {} 
bitAligment = \textless{}MSB \textbar{} LSB\textgreater{}
(
bit aligment of the image data, i.e. for 12b:
{[}MSB - xxxx xxxx xxxx 0000{]}
{[}LSB - 0000 xxxx xxxx xxxx{]}
)

\end{itemize}

\end{description}
\\
\hline\end{tabular}



\section{Attributes}
\label{Pco/pco:attributes}
\begin{longtable}{|p{0.237\linewidth}|p{0.237\linewidth}|p{0.237\linewidth}|p{0.237\linewidth}|}
\hline
\textsf{\relax 
Attribute name
} & \textsf{\relax 
RW
} & \textsf{\relax 
Type
} & \textsf{\relax 
Description
}\\
\hline\endfirsthead

\multicolumn{4}{c}%
{{\tablecontinued{\tablename\ \thetable{} -- continued from previous page}}} \\
\hline
\textsf{\relax 
Attribute name
} & \textsf{\relax 
RW
} & \textsf{\relax 
Type
} & \textsf{\relax 
Description
}\\
\hline\endhead

\hline \multicolumn{4}{|r|}{{\tablecontinued{Continued on next page}}} \\ \hline
\endfoot

\endlastfoot


acqTimeoutRetry
 & 
rw
 & 
DevLong
 & 
Maximum Timeout retries during acq (0 - infinite)
\\
\hline
adc
 & 
rw
 & 
DevLong
 & 
Number of working ADC's
\\
\hline
adcMax
 & 
ro
 & 
DevLong
 & 
Maximum number of ADC's
\\
\hline
binInfo
 & 
ro
 & 
DevLong
 & 
PCO hw binning info
\\
\hline
bitAlignment
 & 
rw
 & 
DevString
 & \begin{description}
\item[{Bit alignment}] \leavevmode\begin{itemize}
\item {} 
MSB (0)

\item {} 
LSB (1)

\end{itemize}

\end{description}
\\
\hline
bytesPerPixel
 & 
ro
 & 
DevLong
 & 
Bytes per Pixel
\\
\hline
camerasFound
 & 
ro
 & 
DevString
 & 
List of cameras found during the Open search
\\
\hline
camInfo
 & 
ro
 & 
DevString
 & 
General camera parameters information
\\
\hline
camName
 & 
ro
 & 
DevString
 & 
Camera Name
\\
\hline
camNameBase
 & 
ro
 & 
DevString
 & 
Camera Name (Pco)
\\
\hline
camNameEx
 & 
ro
 & 
DevString
 & 
Camera Name, Interface, Sensor
\\
\hline
camType
 & 
ro
 & 
DevString
 & 
Camera Type
\\
\hline
cdiMode
 & 
rw
 & 
DevLong
 & \begin{description}
\item[{Correlated Double Imaging Mode}] \leavevmode\begin{itemize}
\item {} 
enabled/disabled = 1/0 (rw)

\item {} 
not allowed = -1 (ro)

\end{itemize}

\end{description}
\\
\hline
clXferPar
 & 
ro
 & 
DevString
 & 
General CameraLink parameters
\\
\hline
cocRunTime
 & 
ro
 & 
DevDouble
 & 
cocRunTime (s) - only valid after the camera is armed
\\
\hline
coolingTemperature
 & 
ro
 & 
DevDouble
 & 
Cooling Temperature
\\
\hline
debugInt
 & 
rw
 & 
DevString
 & 
PCO plugin internal debug level (hex format: 0x....)
\\
\hline
debugIntTypes
 & 
r0
 & 
DevString
 & 
PCO plugin internal debug types
\\
\hline
doubleImageMode
 & 
rw
 & 
DevLong
 & \begin{description}
\item[{Double Image Mode}] \leavevmode\begin{itemize}
\item {} 
enabled/disabled = 1/0 (rw)

\item {} 
not allowed = -1 (ro)

\end{itemize}

\end{description}
\\
\hline
firmwareInfo
 & 
ro
 & 
DevString
 & 
Firmware info
\\
\hline
frameRate
 & 
ro
 & 
DevDouble
 & 
Framerate, calculated as: 1/cocRunTime (1/s)
\\
\hline
info
 & 
ro
 & 
DevString
 & 
General camera parameters information
\\
\hline
lastError
 & 
ro
 & 
DevString
 & 
The last PCO error message
\\
\hline
lastImgAcquired
 & 
ro
 & 
DevLong
 & 
Last image acquired (during recording)
\\
\hline
lastImgRecorded
 & 
ro
 & 
DevLong
 & 
Last image recorded (during recording)
\\
\hline
logMsg
 & 
ro
 & 
DevString
 & 
Last Log msgs
\\
\hline
logPcoEnabled
 & 
ro
 & 
DevLong
 & 
PCO logs are enabled
\\
\hline
maxNbImages
 & 
ro
 & 
DevLong
 & 
The maximum number of images which can be acquired by the camera (recording mode)
\\
\hline
pixelRate
 & 
ro
 & 
DevLong
 & 
Actual Pixel Rate (Hz)
\\
\hline
pixelRateInfo
 & 
ro
 & 
DevString
 & 
Pixel Rate information
\\
\hline
pixelRateValidValues
 & 
ro
 & 
DevString
 & 
Allowed Pixel Rates
\\
\hline
roiInfo
 & 
ro
 & 
DevString
 & 
PCO ROI info
\\
\hline
roiLastFixed
 & 
ro
 & 
DevString
 & 
Last fixed ROI info
\\
\hline
rollingShutter
 & 
rw
 & 
DevLong
 & \begin{description}
\item[{Rolling Shutter Mode (\textbf{only for some types of EDGE})}] \leavevmode\begin{itemize}
\item {} 
1 = ROLLING

\item {} 
2 = GLOBAL

\item {} 
4 = GLOBAL RESET

\end{itemize}

\end{description}
\\
\hline
rollingShutterInfo
 & 
ro
 & 
DevString
 & 
Rolling Shutter info
\\
\hline
temperatureInfo
 & 
ro
 & 
DevString
 & 
Temperature info
\\
\hline
timestampMode
 & 
rw
 & 
DevLong
 & \begin{description}
\item[{Timestamp mode}] \leavevmode\begin{itemize}
\item {} 
0 = none

\item {} 
1 = BCD coded stamp in the first 14 pixel

\item {} 
2 = BCD coded stamp in the first 14 pixel + ASCII text

\item {} 
3 = ASCII text (\textbf{only for some cameras})

\end{itemize}

\end{description}
\\
\hline
traceAcq
 & 
ro
 & 
DevString
 & 
Debug information for some types of acq
\\
\hline
version
 & 
ro
 & 
DevString
 & 
Version information of the plugin
\\
\hline
versionAtt
 & 
ro
 & 
DevString
 & 
Version of att file
\\
\hline
versionSdk
 & 
ro
 & 
DevString
 & 
PCO SDK Release
\\
\hline\end{longtable}



\section{Commands}
\label{Pco/pco:commands}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textsf{\relax 
Command name
} & \textsf{\relax 
Arg. in
} & \textsf{\relax 
Arg. out
} & \textsf{\relax 
Description
}\\
\hline
Init
 & 
DevVoid
 & 
DevVoid
 & 
Do NOT use
\\
\hline
State
 & 
DevVoid
 & 
DevLong
 & 
Return the device state
\\
\hline
Status
 & 
DevVoid
 & 
DevString
 & 
Return the device state as a string
\\
\hline
getAttrStringValueList
 & 
DevString:
Attribute name
 & 
DevVarStringArray:
String value list
 & 
Return the authorized string value list for
a given attribute name
\\
\hline
talk
 & 
DevString
 & 
DevString
 & 
\textbf{WARNING}: use this command for test only,
This is a backdoor cmd and it can distrub Lima
\\
\hline\end{tabulary}




\renewcommand{\indexname}{Index}
\printindex
\end{document}
