static const char *RcsId = "$Id:  $";
//+=============================================================================
//
// file :         Eiger.cpp
//
// description :  C++ source for the Eiger and its commands.
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                Eiger are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author:  $
//
// $Revision:  $
//
// $Revision:  $
// $Date:  $
//
// SVN only:
// $HeadURL: $
//
// CVS only:
// $Source:  $
// $Log:  $
//
// copyleft :    Synchrotron SOLEIL
//               L'Orme des merisiers - Saint Aubin
//               BP48 - 91192 Gif sur Yvette
//               FRANCE
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================



//===================================================================
//
//	The following table gives the correspondence
//	between commands and method name.
//
//  Command name|  Method name
//	----------------------------------------
//  State       |  dev_state()
//  Status      |  dev_status()
//  Abort       |  abort()
//  Initialize  |  initialize()
//
//===================================================================


#include "tango.h"
#include <PogoHelper.h>
#include <Eiger.h>
#include <EigerClass.h>


namespace Eiger_ns
{

//+----------------------------------------------------------------------------
//
// method : 		Eiger::Eiger(string &s)
//
// description : 	constructor for simulated Eiger
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name
//
//-----------------------------------------------------------------------------
Eiger::Eiger(Tango::DeviceClass *cl, string &s)
:Tango::Device_4Impl(cl, s.c_str())
{
    init_device();
}
Eiger::Eiger(Tango::DeviceClass *cl, const char *s)
:Tango::Device_4Impl(cl, s)
{
    init_device();
}
Eiger::Eiger(Tango::DeviceClass *cl, const char *s, const char *d)
:Tango::Device_4Impl(cl, s, d)
{
    init_device();
}
//+----------------------------------------------------------------------------
//
// method : 		Eiger::delete_device()
//
// description : 	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void Eiger::delete_device()
{
    //	Delete device allocated objects

    DELETE_SCALAR_ATTRIBUTE(attr_countrateCorrection_read);
    DELETE_SCALAR_ATTRIBUTE(attr_flatfieldCorrection_read);
    DELETE_SCALAR_ATTRIBUTE(attr_pixelMask_read);
    DELETE_SCALAR_ATTRIBUTE(attr_thresholdEnergy_read);
    DELETE_SCALAR_ATTRIBUTE(attr_virtualPixelCorrection_read);
    DELETE_SCALAR_ATTRIBUTE(attr_wavelength_read);
    DELETE_SCALAR_ATTRIBUTE(attr_beamCenterX_read);
    DELETE_SCALAR_ATTRIBUTE(attr_beamCenterY_read);
    DELETE_SCALAR_ATTRIBUTE(attr_detectorDistance_read);
    DELETE_SCALAR_ATTRIBUTE(attr_photonEnergy_read);
    DELETE_SCALAR_ATTRIBUTE(attr_temperature_read);
    DELETE_SCALAR_ATTRIBUTE(attr_humidity_read);
    DELETE_SCALAR_ATTRIBUTE(attr_compression_read);
    DELETE_SCALAR_ATTRIBUTE(attr_autoSummation_read);        
    DELETE_SCALAR_ATTRIBUTE(attr_fileNamePattern_read);
    DELETE_SCALAR_ATTRIBUTE(attr_softwareVersion_read);
    DELETE_SCALAR_ATTRIBUTE(attr_dataCollectionDate_read);
}

//+----------------------------------------------------------------------------
//
// method : 		Eiger::init_device()
//
// description : 	will be called at device initialization.
//
//-----------------------------------------------------------------------------
void Eiger::init_device()
{
    INFO_STREAM << "Eiger::Eiger() create device " << device_name << endl;

    // Initialise variables to default values
    //--------------------------------------------
    get_device_property();

    CREATE_SCALAR_ATTRIBUTE(attr_countrateCorrection_read);
    CREATE_SCALAR_ATTRIBUTE(attr_flatfieldCorrection_read);
    CREATE_SCALAR_ATTRIBUTE(attr_pixelMask_read);
    CREATE_SCALAR_ATTRIBUTE(attr_thresholdEnergy_read);
    CREATE_SCALAR_ATTRIBUTE(attr_virtualPixelCorrection_read);
    CREATE_SCALAR_ATTRIBUTE(attr_wavelength_read);
    CREATE_SCALAR_ATTRIBUTE(attr_beamCenterX_read);
    CREATE_SCALAR_ATTRIBUTE(attr_beamCenterY_read);
    CREATE_SCALAR_ATTRIBUTE(attr_detectorDistance_read);
    CREATE_SCALAR_ATTRIBUTE(attr_photonEnergy_read);
    CREATE_SCALAR_ATTRIBUTE(attr_temperature_read);
    CREATE_SCALAR_ATTRIBUTE(attr_humidity_read);
    CREATE_SCALAR_ATTRIBUTE(attr_compression_read);
    CREATE_SCALAR_ATTRIBUTE(attr_autoSummation_read);    
    CREATE_DEVSTRING_ATTRIBUTE(attr_fileNamePattern_read, MAX_ATTRIBUTE_STRING_LENGTH);
    CREATE_DEVSTRING_ATTRIBUTE(attr_softwareVersion_read, MAX_ATTRIBUTE_STRING_LENGTH);
    CREATE_DEVSTRING_ATTRIBUTE(attr_dataCollectionDate_read, MAX_ATTRIBUTE_STRING_LENGTH);

    m_is_device_initialized = false;
    set_state(Tango::INIT);
    m_status_message.str("");
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        //- get the main object used to pilot the lima framework		
        m_ct = ControlFactory::instance().get_control("Eiger");
        if(m_ct == 0)
        {
            INFO_STREAM << "Initialization Failed : Unable to get the lima control of " << "(" << "Eiger" << ") !" << endl;
            m_status_message << "Initialization Failed : Unable to get the lima control of " << "(" << "Eiger" << ") !" << endl;
            m_is_device_initialized = false;
            set_state(Tango::FAULT);
            return;
        }

        //- get interface to specific camera
        m_hw = dynamic_cast<lima::Eiger::Interface*>(m_ct->hwInterface());

        //- get camera to specific detector
        m_camera = &(m_hw->getCamera());

    }
    catch(Exception& e)
    {
        INFO_STREAM << "Initialization Failed : " << e.getErrMsg() << endl;
        m_status_message << "Initialization Failed : " << e.getErrMsg( ) << endl;
        m_is_device_initialized = false;
        set_state(Tango::FAULT);
        return;
    }
    catch(...)
    {
        INFO_STREAM << "Initialization Failed : UNKNOWN" << endl;
        m_status_message << "Initialization Failed : UNKNOWN" << endl;
        set_state(Tango::FAULT);
        m_is_device_initialized = false;
        return;
    }

    // Write at init
    try
    {
        // Init attributes with memorized properties	
        //------------------------------------------
        INFO_STREAM << "Write tango hardware at Init - fileNamePattern." << endl;
        Tango::WAttribute &fileNamePattern = dev_attr->get_w_attr_by_name("fileNamePattern");
        m_file_name_pattern = memorizedFileNamePattern;
        strcpy(*attr_fileNamePattern_read, m_file_name_pattern.c_str());
        fileNamePattern.set_write_value(*attr_fileNamePattern_read);
        write_fileNamePattern(fileNamePattern);
    }
    catch(Exception& e)
    {
        INFO_STREAM << "-- Initialization Failed : " << e.getErrMsg() << endl;
        m_status_message << "Initialization Failed : " << e.getErrMsg( ) << endl;
        m_is_device_initialized = false;
        set_state(Tango::FAULT);
        return;
    }
    catch(...)
    {
        INFO_STREAM << "-- Initialization Failed : UNKNOWN" << endl;
        m_status_message << "Initialization Failed : UNKNOWN" << endl;
        set_state(Tango::FAULT);
        m_is_device_initialized = false;
        return;
    }

    m_is_device_initialized = true;
    set_state(Tango::STANDBY);
    dev_state();
}


//+----------------------------------------------------------------------------
//
// method : 		Eiger::get_device_property()
//
// description : 	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void Eiger::get_device_property()
{
    //	Initialize your default values here (if not done with  POGO).
    //------------------------------------------------------------------

    //	Read device properties from database.(Automatic code generation)
    //------------------------------------------------------------------
    Tango::DbData	dev_prop;
    dev_prop.push_back(Tango::DbDatum("DetectorIP"));
    dev_prop.push_back(Tango::DbDatum("MemorizedFileNamePattern"));
    dev_prop.push_back(Tango::DbDatum("MemorizedCountrateCorrection"));
    dev_prop.push_back(Tango::DbDatum("MemorizedFlatfieldCorrection"));
    dev_prop.push_back(Tango::DbDatum("MemorizedPixelMask"));
    dev_prop.push_back(Tango::DbDatum("MemorizedVirtualPixelCorrection"));
    dev_prop.push_back(Tango::DbDatum("MemorizedThresholdEnergy"));
    dev_prop.push_back(Tango::DbDatum("MemorizedPhotonEnergy"));
    dev_prop.push_back(Tango::DbDatum("MemorizedAutoSummation"));
    dev_prop.push_back(Tango::DbDatum("MemorizedCompression"));
    dev_prop.push_back(Tango::DbDatum("MemorizedWavelength"));
    dev_prop.push_back(Tango::DbDatum("MemorizedBeamCenterX"));
    dev_prop.push_back(Tango::DbDatum("MemorizedBeamCenterY"));
    dev_prop.push_back(Tango::DbDatum("MemorizedDetectorDistance"));

    //	Call database and extract values
    //--------------------------------------------
    if (Tango::Util::instance()->_UseDb==true)
        get_db_device()->get_property(dev_prop);
    Tango::DbDatum	def_prop, cl_prop;
    EigerClass	*ds_class =
    (static_cast<EigerClass *>(get_device_class()));
    int	i = -1;

    //	Try to initialize DetectorIP from class property
    cl_prop = ds_class->get_class_property(dev_prop[++i].name);
    if (cl_prop.is_empty()==false)	cl_prop  >>  detectorIP;
    else
    {
        //	Try to initialize DetectorIP from default device value
        def_prop = ds_class->get_default_device_property(dev_prop[i].name);
        if (def_prop.is_empty()==false)	def_prop  >>  detectorIP;
    }
    //	And try to extract DetectorIP value from database
    if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  detectorIP;

    //	Try to initialize MemorizedFileNamePattern from class property
    cl_prop = ds_class->get_class_property(dev_prop[++i].name);
    if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedFileNamePattern;
    else
    {
        //	Try to initialize MemorizedFileNamePattern from default device value
        def_prop = ds_class->get_default_device_property(dev_prop[i].name);
        if (def_prop.is_empty()==false)	def_prop  >>  memorizedFileNamePattern;
    }
    //	And try to extract MemorizedFileNamePattern value from database
    if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedFileNamePattern;

    //	Try to initialize MemorizedCountrateCorrection from class property
    cl_prop = ds_class->get_class_property(dev_prop[++i].name);
    if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedCountrateCorrection;
    else
    {
        //	Try to initialize MemorizedCountrateCorrection from default device value
        def_prop = ds_class->get_default_device_property(dev_prop[i].name);
        if (def_prop.is_empty()==false)	def_prop  >>  memorizedCountrateCorrection;
    }
    //	And try to extract MemorizedCountrateCorrection value from database
    if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedCountrateCorrection;

    //	Try to initialize MemorizedFlatfieldCorrection from class property
    cl_prop = ds_class->get_class_property(dev_prop[++i].name);
    if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedFlatfieldCorrection;
    else
    {
        //	Try to initialize MemorizedFlatfieldCorrection from default device value
        def_prop = ds_class->get_default_device_property(dev_prop[i].name);
        if (def_prop.is_empty()==false)	def_prop  >>  memorizedFlatfieldCorrection;
    }
    //	And try to extract MemorizedFlatfieldCorrection value from database
    if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedFlatfieldCorrection;

    //	Try to initialize MemorizedPixelMask from class property
    cl_prop = ds_class->get_class_property(dev_prop[++i].name);
    if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedPixelMask;
    else
    {
        //	Try to initialize MemorizedPixelMask from default device value
        def_prop = ds_class->get_default_device_property(dev_prop[i].name);
        if (def_prop.is_empty()==false)	def_prop  >>  memorizedPixelMask;
    }
    //	And try to extract MemorizedPixelMask value from database
    if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedPixelMask;

    //	Try to initialize MemorizedVirtualPixelCorrection from class property
    cl_prop = ds_class->get_class_property(dev_prop[++i].name);
    if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedVirtualPixelCorrection;
    else
    {
        //	Try to initialize MemorizedVirtualPixelCorrection from default device value
        def_prop = ds_class->get_default_device_property(dev_prop[i].name);
        if (def_prop.is_empty()==false)	def_prop  >>  memorizedVirtualPixelCorrection;
    }
    //	And try to extract MemorizedVirtualPixelCorrection value from database
    if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedVirtualPixelCorrection;

    //	Try to initialize MemorizedThresholdEnergy from class property
    cl_prop = ds_class->get_class_property(dev_prop[++i].name);
    if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedThresholdEnergy;
    else
    {
        //	Try to initialize MemorizedThresholdEnergy from default device value
        def_prop = ds_class->get_default_device_property(dev_prop[i].name);
        if (def_prop.is_empty()==false)	def_prop  >>  memorizedThresholdEnergy;
    }
    //	And try to extract MemorizedThresholdEnergy value from database
    if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedThresholdEnergy;

    //	Try to initialize MemorizedPhotonEnergy from class property
    cl_prop = ds_class->get_class_property(dev_prop[++i].name);
    if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedPhotonEnergy;
    else
    {
        //	Try to initialize MemorizedPhotonEnergy from default device value
        def_prop = ds_class->get_default_device_property(dev_prop[i].name);
        if (def_prop.is_empty()==false)	def_prop  >>  memorizedPhotonEnergy;
    }
    //	And try to extract MemorizedPhotonEnergy value from database
    if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedPhotonEnergy;

    //	Try to initialize MemorizedAutoSummation from class property
    cl_prop = ds_class->get_class_property(dev_prop[++i].name);
    if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedAutoSummation;
    else
    {
        //	Try to initialize MemorizedAutoSummation from default device value
        def_prop = ds_class->get_default_device_property(dev_prop[i].name);
        if (def_prop.is_empty()==false)	def_prop  >>  memorizedAutoSummation;
    }
    //	And try to extract MemorizedAutoSummation value from database
    if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedAutoSummation;

    //	Try to initialize MemorizedCompression from class property
    cl_prop = ds_class->get_class_property(dev_prop[++i].name);
    if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedCompression;
    else
    {
        //	Try to initialize MemorizedCompression from default device value
        def_prop = ds_class->get_default_device_property(dev_prop[i].name);
        if (def_prop.is_empty()==false)	def_prop  >>  memorizedCompression;
    }
    //	And try to extract MemorizedCompression value from database
    if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedCompression;

    //	Try to initialize MemorizedWavelength from class property
    cl_prop = ds_class->get_class_property(dev_prop[++i].name);
    if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedWavelength;
    else
    {
        //	Try to initialize MemorizedWavelength from default device value
        def_prop = ds_class->get_default_device_property(dev_prop[i].name);
        if (def_prop.is_empty()==false)	def_prop  >>  memorizedWavelength;
    }
    //	And try to extract MemorizedWavelength value from database
    if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedWavelength;

    //	Try to initialize MemorizedBeamCenterX from class property
    cl_prop = ds_class->get_class_property(dev_prop[++i].name);
    if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedBeamCenterX;
    else
    {
        //	Try to initialize MemorizedBeamCenterX from default device value
        def_prop = ds_class->get_default_device_property(dev_prop[i].name);
        if (def_prop.is_empty()==false)	def_prop  >>  memorizedBeamCenterX;
    }
    //	And try to extract MemorizedBeamCenterX value from database
    if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedBeamCenterX;

    //	Try to initialize MemorizedBeamCenterY from class property
    cl_prop = ds_class->get_class_property(dev_prop[++i].name);
    if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedBeamCenterY;
    else
    {
        //	Try to initialize MemorizedBeamCenterY from default device value
        def_prop = ds_class->get_default_device_property(dev_prop[i].name);
        if (def_prop.is_empty()==false)	def_prop  >>  memorizedBeamCenterY;
    }
    //	And try to extract MemorizedBeamCenterY value from database
    if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedBeamCenterY;

    //	Try to initialize MemorizedDetectorDistance from class property
    cl_prop = ds_class->get_class_property(dev_prop[++i].name);
    if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedDetectorDistance;
    else
    {
        //	Try to initialize MemorizedDetectorDistance from default device value
        def_prop = ds_class->get_default_device_property(dev_prop[i].name);
        if (def_prop.is_empty()==false)	def_prop  >>  memorizedDetectorDistance;
    }
    //	And try to extract MemorizedDetectorDistance value from database
    if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedDetectorDistance;



    //	End of Automatic code generation
    //------------------------------------------------------------------
    yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "127.0.0.1", "DetectorIP");
    yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "/tmp", 	 "TargetPath");
    yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "lima", 	 "FileNamePattern");
    yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "false", 	 "MemorizedCountrateCorrection");
    yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "true", 	 "MemorizedFlatfieldCorrection");
    yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "false",	 "MemorizedPixelMask");
    yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "true",	     "MemorizedVirtualPixelCorrection");
    yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "4000.0",    "MemorizedThresholdEnergy");
    yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "8000.0", 	 "MemorizedPhotonEnergy");
    yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "true", 	 "MemorizedCompression");
    yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "0.0",       "MemorizedBeamCenterX");
    yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "0.0",       "MemorizedBeamCenterY");
    yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "0.0",       "MemorizedWavelength");
    yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "0.0",       "MemorizedDetectorDistance");
    yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "true", 	 "UseDownloader");
    yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "true", 	 "UseReader");
    yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "false", 	 "UseVerboseRestful");
}
//+----------------------------------------------------------------------------
//
// method : 		Eiger::always_executed_hook()
//
// description : 	method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void Eiger::always_executed_hook()
{
    try
    {
        m_status_message.str("");
        yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
        //- get the singleton control objet used to pilot the lima framework
        m_ct = ControlFactory::instance().get_control("Eiger");
        if (m_ct != 0)
        {
            //- get interface to specific camera
            m_hw = dynamic_cast<lima::Eiger::Interface*> (m_ct->hwInterface());
            //- get camera to specific detector
            m_camera = &(m_hw->getCamera());
        }

        //update state
        dev_state();
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        m_status_message << "Initialization Failed : " << e.getErrMsg() << endl;
        //- throw exception
        set_state(Tango::FAULT);
        m_is_device_initialized = false;
        return;
    }
    catch (...)
    {
        ERROR_STREAM << "Initialization Failed : UNKNOWN" << endl;
        m_status_message << "Initialization Failed : UNKNOWN" << endl;
        //- throw exception
        set_state(Tango::FAULT);
        m_is_device_initialized = false;
        return;
    }
}
//+----------------------------------------------------------------------------
//
// method : 		Eiger::read_attr_hardware
//
// description : 	Hardware acquisition for attributes.
//
//-----------------------------------------------------------------------------
void Eiger::read_attr_hardware(vector<long> &attr_list)
{
    DEBUG_STREAM << "Eiger::read_attr_hardware(vector<long> &attr_list) entering... "<< endl;
    //	Add your own code here
}
//+----------------------------------------------------------------------------
//
// method : 		Eiger::read_autoSummation
// 
// description : 	Extract real attribute values for autoSummation acquisition result.
//
//-----------------------------------------------------------------------------
void Eiger::read_autoSummation(Tango::Attribute &attr)
{
    DEBUG_STREAM << "Eiger::read_autoSummation(Tango::Attribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        if ( Tango::STANDBY == get_state() )
        {
            m_camera->getAutoSummation(*attr_compression_read);
            attr_autoSummation_read_cache = *attr_autoSummation_read;
        }
        else if ( Tango::RUNNING == get_state() ) // use the cached value while in RUNNING state
        {
            *attr_autoSummation_read = attr_autoSummation_read_cache;
        }

        attr.set_value(attr_autoSummation_read);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          "TANGO_DEVICE_ERROR",
                                          string(df.errors[0].desc).c_str(),
                                          "Eiger::read_autoSummation");
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR", 
                                       e.getErrMsg().c_str(), 
                                       "Eiger::read_autoSummation" );
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Eiger::write_autoSummation
// 
// description : 	Write autoSummation attribute values to hardware.
//
//-----------------------------------------------------------------------------
void Eiger::write_autoSummation(Tango::WAttribute &attr)
{
    DEBUG_STREAM << "Eiger::write_autoSummation(Tango::WAttribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        attr.get_write_value(attr_autoSummation_write);
        m_camera->setAutoSummation(attr_autoSummation_write);
        yat4tango::PropertyHelper::set_property(this, "MemorizedAutoSummation", attr_autoSummation_write);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          "TANGO_DEVICE_ERROR",
                                          string(df.errors[0].desc).c_str(),
                                          "Eiger::write_autoSummation");
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception("TANGO_DEVICE_ERROR", 
                                       e.getErrMsg().c_str(), 
                                       "Eiger::write_autoSummation");
    }    
}

//+----------------------------------------------------------------------------
//
// method : 		Eiger::read_detectorDistance
// 
// description : 	Extract real attribute values for detectorDistance acquisition result.
//
//-----------------------------------------------------------------------------
void Eiger::read_detectorDistance(Tango::Attribute &attr)
{
    DEBUG_STREAM << "Eiger::read_detectorDistance(Tango::Attribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
                if ( Tango::STANDBY == get_state() )
                {
                    m_camera->getDetectorDistance(*attr_detectorDistance_read);
                    attr_detectorDistance_read_cache = *attr_detectorDistance_read;
                }
                else if ( Tango::RUNNING == get_state() ) // use the cached value while in RUNNING state
                {
                    *attr_detectorDistance_read = attr_detectorDistance_read_cache;
                }
        
                attr.set_value(attr_detectorDistance_read);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                                          static_cast<const char*> (string(df.errors[0].desc).c_str()),
                                          static_cast<const char*> ("Eiger::read_detectorDistance"));
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR", e.getErrMsg().c_str(), "Eiger::read_detectorDistance" );
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Eiger::write_detectorDistance
// 
// description : 	Write detectorDistance attribute values to hardware.
//
//-----------------------------------------------------------------------------
void Eiger::write_detectorDistance(Tango::WAttribute &attr)
{
    DEBUG_STREAM << "Eiger::write_detectorDistance(Tango::WAttribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
                attr.get_write_value(attr_detectorDistance_write);
                m_camera->setDetectorDistance(attr_detectorDistance_write);
                yat4tango::PropertyHelper::set_property(this, "MemorizedDetectorDistance", attr_detectorDistance_write);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                                          static_cast<const char*> (string(df.errors[0].desc).c_str()),
                                          static_cast<const char*> ("Eiger::write_detectorDistance"));
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR", e.getErrMsg().c_str(), "Eiger::write_detectorDistance" );
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Eiger::read_wavelength
// 
// description : 	Extract real attribute values for wavelength acquisition result.
//
//-----------------------------------------------------------------------------
void Eiger::read_wavelength(Tango::Attribute &attr)
{
    DEBUG_STREAM << "Eiger::read_wavelength(Tango::Attribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
                if ( Tango::STANDBY == get_state() )
                {
                    m_camera->getWavelength(*attr_wavelength_read);
                    attr_wavelength_read_cache = *attr_wavelength_read;
                }
                else if ( Tango::RUNNING == get_state() ) // use the cached value while in RUNNING state
                {
                    *attr_wavelength_read = attr_wavelength_read_cache;
                }
        
                attr.set_value(attr_wavelength_read);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                                          static_cast<const char*> (string(df.errors[0].desc).c_str()),
                                          static_cast<const char*> ("Eiger::read_wavelength"));
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR", e.getErrMsg().c_str(), "Eiger::read_wavelength" );
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Eiger::write_wavelength
// 
// description : 	Write wavelength attribute values to hardware.
//
//-----------------------------------------------------------------------------
void Eiger::write_wavelength(Tango::WAttribute &attr)
{
    DEBUG_STREAM << "Eiger::write_wavelength(Tango::WAttribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
                attr.get_write_value(attr_wavelength_write);
                m_camera->setWavelength(attr_wavelength_write);
                yat4tango::PropertyHelper::set_property(this, "MemorizedWavelength", attr_wavelength_write);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                                          static_cast<const char*> (string(df.errors[0].desc).c_str()),
                                          static_cast<const char*> ("Eiger::write_wavelength"));
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR", e.getErrMsg().c_str(), "Eiger::write_wavelength" );
    }
}



//+----------------------------------------------------------------------------
//
// method : 		Eiger::read_beamCenterX
// 
// description : 	Extract real attribute values for beamCenterX acquisition result.
//
//-----------------------------------------------------------------------------
void Eiger::read_beamCenterX(Tango::Attribute &attr)
{
    DEBUG_STREAM << "Eiger::read_beamCenterX(Tango::Attribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
                if ( Tango::STANDBY == get_state() )
                {
                    m_camera->getBeamCenterX(*attr_beamCenterX_read);
                    attr_beamCenterX_read_cache = *attr_beamCenterX_read;
                }
                else if ( Tango::RUNNING == get_state() ) // use the cached value while in RUNNING state
                {
                    *attr_beamCenterX_read = attr_beamCenterX_read_cache;
                }
        
                attr.set_value(attr_beamCenterX_read);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                                          static_cast<const char*> (string(df.errors[0].desc).c_str()),
                                          static_cast<const char*> ("Eiger::read_beamCenterX"));
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR", e.getErrMsg().c_str(), "Eiger::read_beamCenterX" );
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Eiger::write_beamCenterX
// 
// description : 	Write beamCenterX attribute values to hardware.
//
//-----------------------------------------------------------------------------
void Eiger::write_beamCenterX(Tango::WAttribute &attr)
{
    DEBUG_STREAM << "Eiger::write_beamCenterX(Tango::WAttribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
                attr.get_write_value(attr_beamCenterX_write);
                m_camera->setBeamCenterX(attr_beamCenterX_write);
                yat4tango::PropertyHelper::set_property(this, "MemorizedBeamCenterX", attr_beamCenterX_write);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                                          static_cast<const char*> (string(df.errors[0].desc).c_str()),
                                          static_cast<const char*> ("Eiger::write_beamCenterX"));
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR", e.getErrMsg().c_str(), "Eiger::write_beamCenterX" );
    }
}


//+----------------------------------------------------------------------------
//
// method : 		Eiger::read_beamCenterY
// 
// description : 	Extract real attribute values for beamCenterY acquisition result.
//
//-----------------------------------------------------------------------------
void Eiger::read_beamCenterY(Tango::Attribute &attr)
{
    DEBUG_STREAM << "Eiger::read_beamCenterY(Tango::Attribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
                if ( Tango::STANDBY == get_state() )
                {
                    m_camera->getBeamCenterY(*attr_beamCenterY_read);
                    attr_beamCenterY_read_cache = *attr_beamCenterY_read;
                }
                else if ( Tango::RUNNING == get_state() ) // use the cached value while in RUNNING state
                {
                    *attr_beamCenterY_read = attr_beamCenterY_read_cache;
                }
        
                attr.set_value(attr_beamCenterY_read);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                                          static_cast<const char*> (string(df.errors[0].desc).c_str()),
                                          static_cast<const char*> ("Eiger::read_beamCenterY"));
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR", e.getErrMsg().c_str(), "Eiger::read_beamCenterY" );
    }
}


//+----------------------------------------------------------------------------
//
// method : 		Eiger::write_beamCenterY
// 
// description : 	Write beamCenterY attribute values to hardware.
//
//-----------------------------------------------------------------------------
void Eiger::write_beamCenterY(Tango::WAttribute &attr)
{
    DEBUG_STREAM << "Eiger::write_beamCenterY(Tango::WAttribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
                attr.get_write_value(attr_beamCenterY_write);
                m_camera->setBeamCenterY(attr_beamCenterY_write);
                yat4tango::PropertyHelper::set_property(this, "MemorizedBeamCenterY", attr_beamCenterY_write);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                                          static_cast<const char*> (string(df.errors[0].desc).c_str()),
                                          static_cast<const char*> ("Eiger::write_beamCenterY"));
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR", e.getErrMsg().c_str(), "Eiger::write_beamCenterY" );
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Eiger::read_softwareVersion
// 
// description : 	Extract real attribute values for softwareVersion acquisition result.
//
//-----------------------------------------------------------------------------
void Eiger::read_softwareVersion(Tango::Attribute &attr)
{
    DEBUG_STREAM << "Eiger::read_softwareVersion(Tango::Attribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
                if ( Tango::STANDBY == get_state() )
                {
                    m_camera->getSoftwareVersion(attr_softwareVersion_read_cache);
                    strcpy(*attr_softwareVersion_read, attr_softwareVersion_read_cache.c_str());
                }
                else if ( Tango::RUNNING == get_state() ) // use the cached value while in RUNNING state
                {
                    strcpy(*attr_softwareVersion_read, attr_softwareVersion_read_cache.c_str());
                }
        
                attr.set_value(attr_softwareVersion_read);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                                          static_cast<const char*> (string(df.errors[0].desc).c_str()),
                                          static_cast<const char*> ("Eiger::read_softwareVersion"));
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR", e.getErrMsg().c_str(), "Eiger::read_softwareVersion" );
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Eiger::read_dataCollectionDate
// 
// description : 	Extract real attribute values for dataCollectionDate acquisition result.
//
//-----------------------------------------------------------------------------
void Eiger::read_dataCollectionDate(Tango::Attribute &attr)
{
    DEBUG_STREAM << "Eiger::read_dataCollectionDate(Tango::Attribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
                if ( Tango::STANDBY == get_state() )
                {
                    m_camera->getDataCollectionDate(attr_dataCollectionDate_read_cache);
                    strcpy(*attr_dataCollectionDate_read, attr_dataCollectionDate_read_cache.c_str());
                }
                else if ( Tango::RUNNING == get_state() ) // use the cached value while in RUNNING state
                {
                    strcpy(*attr_dataCollectionDate_read, attr_dataCollectionDate_read_cache.c_str());
                }
        
                attr.set_value(attr_dataCollectionDate_read);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                                          static_cast<const char*> (string(df.errors[0].desc).c_str()),
                                          static_cast<const char*> ("Eiger::read_dataCollectionDate"));
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR", e.getErrMsg().c_str(), "Eiger::read_dataCollectionDate" );
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Eiger::read_fileNamePattern
// 
// description : 	Extract real attribute values for fileNamePattern acquisition result.
//
//-----------------------------------------------------------------------------
void Eiger::read_fileNamePattern(Tango::Attribute &attr)
{
    DEBUG_STREAM << "Eiger::read_fileNamePattern(Tango::Attribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        //        strcpy(*attr_fileNamePattern_read, m_file_name_pattern.c_str());
        //        attr.set_value(attr_fileNamePattern_read);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                                          static_cast<const char*> (string(df.errors[0].desc).c_str()),
                                          static_cast<const char*>("Eiger::read_fileNamePattern"));
    }
    catch(Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR", e.getErrMsg().c_str(), "Eiger::read_fileNamePattern" );
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Eiger::write_fileNamePattern
// 
// description : 	Write fileNamePattern attribute values to hardware.
//
//-----------------------------------------------------------------------------
void Eiger::write_fileNamePattern(Tango::WAttribute &attr)
{
    DEBUG_STREAM << "Eiger::write_fileNamePattern(Tango::WAttribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        //        attr.get_write_value(attr_fileNamePattern_write);
        //        m_file_name_pattern = attr_fileNamePattern_write;
        //        m_camera->setFileNamePattern(m_file_name_pattern);
        //        PropertyHelper::set_property(this, "MemorizedFileNamePattern", m_file_name_pattern);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                                          static_cast<const char*> (string(df.errors[0].desc).c_str()),
                                          static_cast<const char*>("Eiger::write_fileNamePattern"));
    }
    catch(Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR", e.getErrMsg().c_str(), "Eiger::write_fileNamePattern" );
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Eiger::read_compression
// 
// description : 	Extract real attribute values for compression acquisition result.
//
//-----------------------------------------------------------------------------
void Eiger::read_compression(Tango::Attribute &attr)
{
    DEBUG_STREAM << "Eiger::read_compression(Tango::Attribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        if ( Tango::STANDBY == get_state() )
        {
            m_camera->getCompression(*attr_compression_read);
            attr_compression_read_cache = *attr_compression_read;
        }
        else if ( Tango::RUNNING == get_state() ) // use the cached value while in RUNNING state
        {
            *attr_compression_read = attr_compression_read_cache;
        }

        attr.set_value(attr_compression_read);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                                          static_cast<const char*> (string(df.errors[0].desc).c_str()),
                                          static_cast<const char*> ("Eiger::read_compression"));
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR", e.getErrMsg().c_str(), "Eiger::read_compression" );
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Eiger::write_compression
// 
// description : 	Write compression attribute values to hardware.
//
//-----------------------------------------------------------------------------
void Eiger::write_compression(Tango::WAttribute &attr)
{
    DEBUG_STREAM << "Eiger::write_compression(Tango::WAttribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        attr.get_write_value(attr_compression_write);
        m_camera->setCompression(attr_compression_write);
        yat4tango::PropertyHelper::set_property(this, "MemorizedCompression", attr_compression_write);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                                          static_cast<const char*> (string(df.errors[0].desc).c_str()),
                                          static_cast<const char*> ("Eiger::write_compression"));
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR", e.getErrMsg().c_str(), "Eiger::write_compression" );
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Eiger::read_countrateCorrection
// 
// description : 	Extract real attribute values for countrateCorrection acquisition result.
//
//-----------------------------------------------------------------------------
void Eiger::read_countrateCorrection(Tango::Attribute &attr)
{
    DEBUG_STREAM << "Eiger::read_countrateCorrection(Tango::Attribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        if ( Tango::STANDBY == get_state() )
        {
            m_camera->getCountrateCorrection(*attr_countrateCorrection_read);
            attr_countrateCorrection_read_cache = *attr_countrateCorrection_read;
        }
        else if ( Tango::RUNNING == get_state() )	// use the cached value while in RUNNING state
        {
            *attr_countrateCorrection_read = attr_countrateCorrection_read_cache;
        }

        attr.set_value(attr_countrateCorrection_read);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                                          static_cast<const char*> (string(df.errors[0].desc).c_str()),
                                          static_cast<const char*> ("Eiger::read_countrateCorrection"));
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR", e.getErrMsg().c_str(), "Eiger::read_countrateCorrection" );
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Eiger::write_countrateCorrection
// 
// description : 	Write countrateCorrection attribute values to hardware.
//
//-----------------------------------------------------------------------------
void Eiger::write_countrateCorrection(Tango::WAttribute &attr)
{
    DEBUG_STREAM << "Eiger::write_countrateCorrection(Tango::WAttribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        attr.get_write_value(attr_countrateCorrection_write);
        m_camera->setCountrateCorrection(attr_countrateCorrection_write);
        yat4tango::PropertyHelper::set_property(this, "MemorizedCountrateCorrection", attr_countrateCorrection_write);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                                          static_cast<const char*> (string(df.errors[0].desc).c_str()),
                                          static_cast<const char*> ("Eiger::write_countrateCorrection"));
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR", e.getErrMsg().c_str(), "Eiger::write_countrateCorrection" );
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Eiger::read_flatfieldCorrection
// 
// description : 	Extract real attribute values for flatfieldCorrection acquisition result.
//
//-----------------------------------------------------------------------------
void Eiger::read_flatfieldCorrection(Tango::Attribute &attr)
{
    DEBUG_STREAM << "Eiger::read_flatfieldCorrection(Tango::Attribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        if ( Tango::STANDBY == get_state() )
        {
            m_camera->getFlatfieldCorrection(*attr_flatfieldCorrection_read);
            attr_flatfieldCorrection_read_cache = *attr_flatfieldCorrection_read;
        }
        else if ( Tango::RUNNING == get_state() ) // use the cached value while in RUNNING state
        {
            *attr_flatfieldCorrection_read = attr_flatfieldCorrection_read_cache;
        }
        attr.set_value(attr_flatfieldCorrection_read);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                                          static_cast<const char*> (string(df.errors[0].desc).c_str()),
                                          static_cast<const char*> ("Eiger::read_flatfieldCorrection"));
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR", e.getErrMsg().c_str(), "Eiger::read_flatfieldCorrection" );
    }
}


//+----------------------------------------------------------------------------
//
// method : 		Eiger::write_flatfieldCorrection
// 
// description : 	Write flatfieldCorrection attribute values to hardware.
//
//-----------------------------------------------------------------------------
void Eiger::write_flatfieldCorrection(Tango::WAttribute &attr)
{
    DEBUG_STREAM << "Eiger::write_flatfieldCorrection(Tango::WAttribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        attr.get_write_value(attr_flatfieldCorrection_write);
        m_camera->setFlatfieldCorrection(attr_flatfieldCorrection_write);
        yat4tango::PropertyHelper::set_property(this, "MemorizedFlatfieldCorrection", attr_flatfieldCorrection_write);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                                          static_cast<const char*> (string(df.errors[0].desc).c_str()),
                                          static_cast<const char*> ("Eiger::write_flatfieldCorrection"));
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR", e.getErrMsg().c_str(), "Eiger::read_countrateCorrection" );
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Eiger::read_pixelMask
// 
// description : 	Extract real attribute values for pixelMask acquisition result.
//
//-----------------------------------------------------------------------------
void Eiger::read_pixelMask(Tango::Attribute &attr)
{
    DEBUG_STREAM << "Eiger::read_pixelMask(Tango::Attribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        if ( Tango::STANDBY == get_state() )
        {
            m_camera->getPixelMask(*attr_pixelMask_read);
            attr_pixelMask_read_cache = *attr_pixelMask_read;
        }
        else if ( Tango::RUNNING == get_state() ) // use the cached value while in RUNNING state
        {
            *attr_pixelMask_read = attr_pixelMask_read_cache;
        }

        attr.set_value(attr_pixelMask_read);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                                          static_cast<const char*> (string(df.errors[0].desc).c_str()),
                                          static_cast<const char*> ("Eiger::read_pixelMask"));
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR", e.getErrMsg().c_str(), "Eiger::read_pixelMask" );
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Eiger::write_pixelMask
// 
// description : 	Write pixelMask attribute values to hardware.
//
//-----------------------------------------------------------------------------
void Eiger::write_pixelMask(Tango::WAttribute &attr)
{
    DEBUG_STREAM << "Eiger::write_pixelMask(Tango::WAttribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        attr.get_write_value(attr_pixelMask_write);
        m_camera->setPixelMask(attr_pixelMask_write);
        yat4tango::PropertyHelper::set_property(this, "MemorizedPixelMask", attr_pixelMask_write);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                                          static_cast<const char*> (string(df.errors[0].desc).c_str()),
                                          static_cast<const char*> ("Eiger::write_pixelMask"));
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR", e.getErrMsg().c_str(), "Eiger::write_pixelMask" );
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Eiger::read_thresholdEnergy
// 
// description : 	Extract real attribute values for thresholdEnergy acquisition result.
//
//-----------------------------------------------------------------------------
void Eiger::read_thresholdEnergy(Tango::Attribute &attr)
{
    DEBUG_STREAM << "Eiger::read_thresholdEnergy(Tango::Attribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        if ( Tango::STANDBY == get_state() )
        {
            m_camera->getThresholdEnergy(*attr_thresholdEnergy_read);
            attr_thresholdEnergy_read_cache = *attr_thresholdEnergy_read;
        }
        else if ( Tango::RUNNING == get_state() )	// use the cached value while in RUNNING state
        {
            *attr_thresholdEnergy_read = attr_thresholdEnergy_read_cache;
        }

        attr.set_value(attr_thresholdEnergy_read);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                                          static_cast<const char*> (string(df.errors[0].desc).c_str()),
                                          static_cast<const char*> ("Eiger::read_thresholdEnergy"));
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR", e.getErrMsg().c_str(), "Eiger::read_thresholdEnergy" );
    }
}


//+----------------------------------------------------------------------------
//
// method : 		Eiger::write_thresholdEnergy
// 
// description : 	Write thresholdEnergy attribute values to hardware.
//
//-----------------------------------------------------------------------------
void Eiger::write_thresholdEnergy(Tango::WAttribute &attr)
{
    DEBUG_STREAM << "Eiger::write_thresholdEnergy(Tango::WAttribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        attr.get_write_value(attr_thresholdEnergy_write);
        m_camera->setThresholdEnergy(attr_thresholdEnergy_write);
        yat4tango::PropertyHelper::set_property(this, "MemorizedThresholdEnergy", attr_thresholdEnergy_write);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                                          static_cast<const char*> (string(df.errors[0].desc).c_str()),
                                          static_cast<const char*> ("Eiger::write_thresholdEnergy"));
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR", e.getErrMsg().c_str(), "Eiger::write_thresholdEnergy" );
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Eiger::read_virtualPixelCorrection
// 
// description : 	Extract real attribute values for virtualPixelCorrection acquisition result.
//
//-----------------------------------------------------------------------------
void Eiger::read_virtualPixelCorrection(Tango::Attribute &attr)
{
    DEBUG_STREAM << "Eiger::read_virtualPixelCorrection(Tango::Attribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        if ( Tango::STANDBY == get_state() )
        {
            m_camera->getVirtualPixelCorrection(*attr_virtualPixelCorrection_read);
            attr_virtualPixelCorrection_read_cache = *attr_virtualPixelCorrection_read;
        }
        else if ( Tango::RUNNING == get_state() ) // use the cached value while in RUNNING state
        {
            *attr_virtualPixelCorrection_read = attr_virtualPixelCorrection_read_cache;
        }

        attr.set_value(attr_virtualPixelCorrection_read);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                                          static_cast<const char*> (string(df.errors[0].desc).c_str()),
                                          static_cast<const char*> ("Eiger::read_virtualPixelCorrection"));
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR", e.getErrMsg().c_str(), "Eiger::read_virtualPixelCorrection" );
    }
}


//+----------------------------------------------------------------------------
//
// method : 		Eiger::write_virtualPixelCorrection
// 
// description : 	Write virtualPixelCorrection attribute values to hardware.
//
//-----------------------------------------------------------------------------
void Eiger::write_virtualPixelCorrection(Tango::WAttribute &attr)
{
    DEBUG_STREAM << "Eiger::write_virtualPixelCorrection(Tango::WAttribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        attr.get_write_value(attr_virtualPixelCorrection_write);
        m_camera->setVirtualPixelCorrection(attr_virtualPixelCorrection_write);
        yat4tango::PropertyHelper::set_property(this, "MemorizedVirtualPixelCorrection", attr_virtualPixelCorrection_write);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                                          static_cast<const char*> (string(df.errors[0].desc).c_str()),
                                          static_cast<const char*> ("Eiger::write_virtualPixelCorrection"));
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR", e.getErrMsg().c_str(), "Eiger::write_virtualPixelCorrection" );
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Eiger::read_photonEnergy
// 
// description : 	Extract real attribute values for photonEnergy acquisition result.
//
//-----------------------------------------------------------------------------
void Eiger::read_photonEnergy(Tango::Attribute &attr)
{
    DEBUG_STREAM << "Eiger::read_photonEnergy(Tango::Attribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        if ( Tango::STANDBY == get_state() )
        {
            m_camera->getPhotonEnergy(*attr_photonEnergy_read);
            attr_photonEnergy_read_cache = *attr_photonEnergy_read;
        }
        else if ( Tango::RUNNING == get_state() ) // use the cached value while in RUNNING state
        {
            *attr_photonEnergy_read = attr_photonEnergy_read_cache;
        }

        attr.set_value(attr_photonEnergy_read);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                                          static_cast<const char*> (string(df.errors[0].desc).c_str()),
                                          static_cast<const char*> ("Eiger::read_photonEnergy"));
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR", e.getErrMsg().c_str(), "Eiger::read_photonEnergy" );
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Eiger::write_photonEnergy
// 
// description : 	Write photonEnergy attribute values to hardware.
//
//-----------------------------------------------------------------------------
void Eiger::write_photonEnergy(Tango::WAttribute &attr)
{
    DEBUG_STREAM << "Eiger::write_photonEnergy(Tango::WAttribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        attr.get_write_value(attr_photonEnergy_write);
        m_camera->setPhotonEnergy(attr_photonEnergy_write);
        yat4tango::PropertyHelper::set_property(this, "MemorizedPhotonEnergy", attr_photonEnergy_write);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                                          static_cast<const char*> (string(df.errors[0].desc).c_str()),
                                          static_cast<const char*> ("Eiger::write_photonEnergy"));
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR", e.getErrMsg().c_str(), "Eiger::write_photonEnergy" );
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Eiger::read_temperature
// 
// description : 	Extract real attribute values for temperature acquisition result.
//
//-----------------------------------------------------------------------------
void Eiger::read_temperature(Tango::Attribute &attr)
{
    DEBUG_STREAM << "Eiger::read_temperature(Tango::Attribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        if ( Tango::STANDBY == get_state() )
        {
            m_camera->getTemperature( *attr_temperature_read);
            attr_temperature_read_cache = *attr_temperature_read;
        }
        else if ( Tango::RUNNING == get_state() ) // use the cached value while in RUNNING state
        {
            *attr_temperature_read = attr_temperature_read_cache;
        }
        attr.set_value(attr_temperature_read);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                                          static_cast<const char*> (string(df.errors[0].desc).c_str()),
                                          static_cast<const char*> ("Eiger::read_temperature"));
    }
    catch(Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
                                       static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                                       static_cast<const char*> (e.getErrMsg().c_str()),
                                       static_cast<const char*> ("Eiger::read_temperature"));
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR", e.getErrMsg().c_str(), "Eiger::read_temperature" );
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Eiger::read_humidity
// 
// description : 	Extract real attribute values for humidity acquisition result.
//
//-----------------------------------------------------------------------------
void Eiger::read_humidity(Tango::Attribute &attr)
{
    DEBUG_STREAM << "Eiger::read_humidity(Tango::Attribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        if ( Tango::STANDBY == get_state() )
        {
            m_camera->getHumidity(*attr_humidity_read);
            attr_humidity_read_cache = *attr_humidity_read;
        }
        else if ( Tango::RUNNING == get_state() ) // use the cached value while in RUNNING state
        {
            *attr_humidity_read = attr_humidity_read_cache;
        }
        attr.set_value(attr_humidity_read);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                                          static_cast<const char*> (string(df.errors[0].desc).c_str()),
                                          static_cast<const char*> ("Eiger::read_humidity"));
    }
    catch(Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
                                       static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                                       static_cast<const char*> (e.getErrMsg().c_str()),
                                       static_cast<const char*> ("Eiger::read_humidity"));
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR", e.getErrMsg().c_str(), "Eiger::read_humidity" );
    }
}

//+------------------------------------------------------------------
/**
 *	method:	Eiger::dev_state
 *
 *	description:	method to execute "State"
 *	This command gets the device state (stored in its <i>device_state</i> data member) and returns it to the caller.
 *
 * @return	State Code
 *
 */
//+------------------------------------------------------------------
Tango::DevState Eiger::dev_state()
{
    Tango::DevState	argout = DeviceImpl::dev_state();
    DEBUG_STREAM << "LimaDetector::dev_state(): entering... !" << endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    //	Add your own code to control device here
    stringstream    DeviceStatus;
    DeviceStatus.str("");
    Tango::DevState DeviceState    = Tango::STANDBY;

    //if error during init_device
    if(!m_is_device_initialized )
    {
        DeviceState  = Tango::FAULT;
        DeviceStatus << m_status_message.str();
        DeviceStatus << endl;
    }
    else
    {
        // let's take a look at the status of control & the status of the plugin        
        DeviceState  = ControlFactory::instance().get_state();
        DeviceStatus << ControlFactory::instance().get_status();
    }

    set_state(DeviceState);
    set_status(DeviceStatus.str());

    argout = DeviceState;
    return argout;
}


//+------------------------------------------------------------------
/**
 *	method:	Eiger::abort
 *
 *	description:	method to execute "Abort"
 *
 *
 */
//+------------------------------------------------------------------
void Eiger::abort()
{
    DEBUG_STREAM << "Eiger::abort(): entering... !" << endl;

    //	Add your own code to control device here
    try
    {
        //        m_camera->abort();
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR", e.getErrMsg().c_str(), "Eiger::abort" );
    }
}

//+------------------------------------------------------------------
/**
 *	method:	Eiger::initialize
 *
 *	description:	method to execute "Initialize"
 *
 *
 */
//+------------------------------------------------------------------
void Eiger::initialize()
{
    DEBUG_STREAM << "Eiger::initialize(): entering... !" << endl;

    //	Add your own code to control device here
    try
    {
        m_camera->initialize();
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR", e.getErrMsg().c_str(), "Eiger::initialize" );
    }
}











}	//	namespace
